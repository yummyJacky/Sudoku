/**
 * Sudoku Grid Management Module
 * This module provides functionality for managing both the initial Sudoku grid
 * and the user's playing grid with undo/redo capabilities.
 */

import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
import { hints } from './hints';
import { candidates } from './candidates';

/**
 * Calculates all possible candidates for a cell
 * @param {Array} grid - The current grid
 * @param {number} row - Row index
 * @param {number} col - Column index
 * @returns {Array} Array of candidate numbers
 */
function calculateCellCandidates(grid, row, col) {
    if (grid[row][col] !== 0) {
        return [];
    }

    const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);

    // Check row
    for (let x = 0; x < 9; x++) {
        candidates.delete(grid[row][x]);
    }

    // Check column
    for (let y = 0; y < 9; y++) {
        candidates.delete(grid[y][col]);
    }

    // Check box
    const boxStartRow = Math.floor(row / 3) * 3;
    const boxStartCol = Math.floor(col / 3) * 3;
    for (let y = boxStartRow; y < boxStartRow + 3; y++) {
        for (let x = boxStartCol; x < boxStartCol + 3; x++) {
            candidates.delete(grid[y][x]);
        }
    }

    return Array.from(candidates);
}

/**
 * Calculates candidates for all cells in the grid
 * @param {Array} grid - The current grid
 * @returns {Object} Object containing candidates for each cell
 */
function calculateAllCandidates(grid) {
    const allCandidates = {};
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            const key = `${col},${row}`;
            allCandidates[key] = calculateCellCandidates(grid, row, col);
        }
    }
    return allCandidates;
}

/**
 * Creates the initial Sudoku grid store
 * @returns {Object} Grid store with methods for grid manipulation
 */
function createGrid() {
    // Initialize empty 9x9 grid
    const grid = writable([
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ]);

    return {
        subscribe: grid.subscribe,

        /**
         * Generates a new Sudoku puzzle with specified difficulty
         * @param {number} difficulty - The difficulty level of the puzzle
         */
        generate(difficulty) {
            grid.set(generateSudoku(difficulty));
        },

        /**
         * Decodes a sencode string into a Sudoku grid
         * @param {string} sencode - Encoded Sudoku string
         */
        decodeSencode(sencode) {
            grid.set(decodeSencode(sencode));
        },

        /**
         * Sets grid from a flat array of 81 numbers
         * @param {number[]} numbers - Array of 81 numbers representing the grid
         */
        setFromArray(numbers) {
            if (!Array.isArray(numbers) || numbers.length !== 81) {
                throw new Error('Invalid grid array');
            }

            const newGrid = Array(9).fill(0).map(() => Array(9).fill(0));

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const value = numbers[row * 9 + col];

                    newGrid[row][col] = (value >= 0 && value <= 9) ? value : 0;
                }
            }

            grid.set(newGrid);
        },

        /**
         * Gets value at specified coordinates
         * @param {Array} gridStore - The grid array
         * @param {number} x - X coordinate
         * @param {number} y - Y coordinate
         * @returns {number} Value at coordinates
         */
        get(gridStore, x, y) {
            return gridStore[y][x];
        },

        /**
         * Gets the sencode representation of the grid
         * @param {Array} gridStore - The grid array
         * @returns {string} Encoded grid string
         */
        getSencode(gridStore) {
            return encodeSudoku(gridStore);
        },
    };
}

export const grid = createGrid();

/**
 * Applies strategy changes to the grid
 * @param {Array} grid - The current grid
 * @param {Array} changes - Array of changes to apply
 * @param {Object} candidatesStore - The candidates store
 * @returns {Array} Updated grid
 */
function applyStrategyChanges(grid, changes, candidatesStore) {
    const newGrid = JSON.parse(JSON.stringify(grid));
    
    for (const change of changes) {
        if (change.type === 'set_value') {
            newGrid[change.row][change.col] = change.digit;
        } else if (change.type === 'highlight_candidate') {
            // 高亮候选值
            candidatesStore.highlightCandidate(
                { x: change.col, y: change.row },
                change.digit,
                change.highlightType
            );
        } else if (change.type === 'remove_candidate') {
            // 删除候选值
            const key = `${change.col},${change.row}`;
            candidatesStore.update($store => {
                const candidates = { ...$store.candidates };
                if (candidates[key]) {
                    candidates[key] = candidates[key].filter(d => d !== change.digit);
                    if (candidates[key].length === 0) {
                        delete candidates[key];
                    }
                }
                return { ...$store, candidates };
            });
        }
    }
    
    return newGrid;
}




class StateNode {
    constructor(grid, parent = null) {
        this.grid = JSON.parse(JSON.stringify(grid));
        this.parent = parent;
        this.children = null;  // 子节点

        this.now_set_pos = null;  // 当前设置的位置
        this.pos_valid_branch = new Map();; // 当前状态在位置(i,j)的合法数  (i,j):[1,2,3,4,5,6,7,8,9]
        this.isInvalid = false; // 标记状态是否不可行
        this.no_solution = false; // 标记状态是否无解
    }
}

function createUserGrid(){

    // History management for undo/redo
    const stateMap = new Map(); // 全局状态映射表
    let currentState = null; // 当前状态节点
    let initialState = null; // 初始状态节点
    const MAX_HISTORY_LENGTH = 10000;

    // Initialize empty user grid
    const userGrid = writable([
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ]);

    /**
     * Subscribe to main grid changes to sync user grid
     */
    grid.subscribe($grid => {
        let newGrid = [];
        for (let y = 0; y < SUDOKU_SIZE; y++) {
            newGrid[y] = [];
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                newGrid[y][x] = $grid[y][x];
            }
        }

        const initialStateKey = JSON.stringify(newGrid);
        if (!stateMap.has(initialStateKey)) {
            initialState = new StateNode(newGrid);
            stateMap.set(initialStateKey, initialState);
        } else {
            initialState = stateMap.get(initialStateKey);
        }

        currentState = initialState;
        userGrid.set(newGrid);
    });

    // Subscribe to userGrid changes to update candidates
    userGrid.subscribe($grid => {
        candidates.update($store => ({
            ...$store,
            candidates: calculateAllCandidates($grid)
        }));
    });

    return {
        subscribe: userGrid.subscribe,

        /**
         * Sets a value at specified position and updates history
         * @param {Object} pos - Position {x, y}
         * @param {number} value - Number to set (1-9)
         */
        set: (pos, value) => {
            userGrid.update($userGrid => {

                const newGrid = JSON.parse(JSON.stringify($userGrid));
                newGrid[pos.y][pos.x] = value;

                const newStateKey = JSON.stringify(newGrid); // 将状态转换为字符串作为键
                let newState = stateMap.get(newStateKey);

                if (!newState) {
                    // 如果状态不存在，创建新节点
                    newState = new StateNode(newGrid, currentState);
                    let invalid_cells = checkInvalidCells(newGrid);
                    if (invalid_cells.length > 0) {
                        newState.isInvalid = true;  //非法
                    }else {
                        let valid_number = checkValidNumbers(newGrid, pos);
                        newState.pos_valid_branch.set(`${pos.x},${pos.y}`, valid_number);
                        newState.now_set_pos = pos;
                    }
                    stateMap.set(newStateKey, newState);
                } else {
                    if (newState.now_set_pos !== pos && !newState.isInvalid) {
                        if (!newState.pos_valid_branch.has(`${pos.x},${pos.y}`)) {
                            let valid_number = checkValidNumbers(newGrid, pos);
                            newState.pos_valid_branch.set(`${pos.x},${pos.y}`, valid_number);
                            newState.now_set_pos = pos;
                        }

                        let valid_number = newState.pos_valid_branch.get(`${pos.x},${pos.y}`);
                        let sum = valid_number.reduce((acc, curr) => acc + curr, 0);
                        if (valid_number[value] === 0 && sum==0) {
                            newState.no_solution = true; //无解
                        }else{
                            if (checkInvalidCells(newGrid).length==0) {
                                newState.isInvalid = false;
                            }
                        }
                        stateMap.set(newStateKey, newState);
                    }
                }

                if (currentState) {
                    currentState.children=newState; // 将新状态添加到当前状态的子节点
                }
                currentState = newState; // 更新当前状态
                return newGrid;
            });
        },

        /**
         * Undoes the last move if available
         */
        undo: () => {

            let prevState = currentState.parent;
            while (prevState && (prevState.isInvalid||prevState.no_solution)) {
                if (prevState.isInvalid || prevState.no_solution) {
                    if (prevState.parent) {
                        prevState = prevState.parent;
                    }
                }
                else {
                    let validBranch;
                    if (prevState.parent) {
                        prevState = prevState.parent;
                        validBranch = prevState.pos_valid_branch.get(`${prevState.now_set_pos.x},${prevState.now_set_pos.y}`);
                        if (validBranch && Array.isArray(validBranch)) {
                            if (prevState.children && !(prevState.children.isInvalid&&prevState.children.no_solution)) {
                                // 无解状态回传
                                validBranch[prevState.grid[prevState.now_set_pos.y][prevState.now_set_pos.x]] = 0;
                                prevState.pos_valid_branch.set(`${prevState.now_set_pos.x},${prevState.now_set_pos.y}`, validBranch);
                            }
                            let sum = validBranch.reduce((acc, curr) => acc + curr, 0);
                            if (sum === 0 || prevState.children && !prevState.children.isInvalid) {
                                if (sum===0) {
                                    prevState.no_solution = true;
                                }
                                stateMap.set(JSON.stringify(prevState.grid), prevState);
                            }
                        }
                    } else {
                        break;
                    }
                }
            }

            if (prevState) {
                currentState = prevState;
                userGrid.set(JSON.parse(JSON.stringify(currentState.grid)));
            }
        },

        ReBragitnch: () => {  //回溯到多分枝节点
            let prevState = currentState;

            while (prevState && (prevState.isInvalid||prevState.no_solution)) {
                if (prevState.isInvalid || prevState.no_solution) {
                    if (prevState.parent) {
                        prevState = prevState.parent;
                    }
                }
                else {
                    let validBranch;
                    if (prevState) {
                        validBranch = prevState.pos_valid_branch.get(`${prevState.now_set_pos.x},${prevState.now_set_pos.y}`);
                        if (validBranch && Array.isArray(validBranch)) {
                            if (prevState.children && !(prevState.children.isInvalid&&prevState.children.no_solution)) {
                                // 无解状态回传
                                validBranch[prevState.grid[prevState.now_set_pos.y][prevState.now_set_pos.x]] = 0;
                                prevState.pos_valid_branch.set(`${prevState.now_set_pos.x},${prevState.now_set_pos.y}`, validBranch);
                            }
                            let sum = validBranch.reduce((acc, curr) => acc + curr, 0);
                            if (sum === 0 || prevState.children && !prevState.children.isInvalid) {
                                if (sum===0) {
                                    prevState.no_solution = true;
                                }
                                stateMap.set(JSON.stringify(prevState.grid), prevState);
                            }
                            if (sum>1){  //多分枝
                                    break;
                            }
                            prevState = prevState.parent;
                        }else{
                            break;
                        }
                    } else {
                        break;
                    }
                }
            }


            if (prevState) {
                currentState = prevState;
                userGrid.set(JSON.parse(JSON.stringify(currentState.grid)));
            }
        },
        /**
         * Redoes the last undone move if available
         */
        redo: () => {
            let nextState = currentState.children;
            while (nextState && (nextState.isInvalid || nextState.no_solution)) {  //跳过非法状态
                nextState = nextState.children;
            }
            if (nextState) {
                currentState = nextState;
                userGrid.set(JSON.parse(JSON.stringify(nextState.grid)));
            }
        },

        /**
         * Applies a strategy at specified position and consumes a hint
         * @param {Object} pos - Position {x, y}
         * @param {Object} strategy - The strategy to apply
         * @param {Object} candidatesStore - The candidates store
         */
        applyStrategy: (pos, strategy, candidatesStore) => {
            hints.useHint();
            console.log('Applying hint at ' + pos.x + ',' + pos.y);
            console.log(strategy);

            userGrid.update($userGrid => {
                const newGrid = JSON.parse(JSON.stringify($userGrid));
                const changes = strategy.effect(newGrid);
                if (changes && changes.length > 0) {
                    applyStrategyChanges(newGrid, changes, candidatesStore);
                }else{
                    if (currentState) {
                        currentState.isInvalid = true;  //无解
                    }
                }

                const newStateKey = JSON.stringify(newGrid); // 将状态转换为字符串作为键
                let newState = stateMap.get(newStateKey);

                if (!newState) {
                    // 如果状态不存在，创建新节点
                    newState = new StateNode(newGrid, currentState);
                    let invalid_cells = checkInvalidCells(newGrid);
                    if (invalid_cells.length > 0) {
                        newState.isInvalid = true;  //非法
                    }else {
                        let valid_number = checkValidNumbers(newGrid, pos);
                        newState.pos_valid_branch.set(`${pos.x},${pos.y}`, valid_number);
                        newState.now_set_pos = pos;
                    }
                    stateMap.set(newStateKey, newState);
                } else {
                    if (newState.now_set_pos !== pos && !newState.isInvalid) {
                        if (!newState.pos_valid_branch.has(`${pos.x},${pos.y}`)) {
                            let valid_number = checkValidNumbers(newGrid, pos);
                            newState.pos_valid_branch.set(`${pos.x},${pos.y}`, valid_number);
                            newState.now_set_pos = pos;
                        }

                        let value = newGrid[pos.x][pos.y];

                        let valid_number = newState.pos_valid_branch.get(`${pos.x},${pos.y}`);
                        let sum = valid_number.reduce((acc, curr) => acc + curr, 0);
                        if (valid_number[value] === 0 && sum==0) {
                            newState.no_solution = true; //无解
                        }else{
                            if (checkInvalidCells(newGrid).length==0) {
                                newState.isInvalid = false;
                                newState.no_solution = false;
                            }
                        }
                        stateMap.set(newStateKey, newState);
                    }
                }

                if (currentState) {
                    currentState.children=newState; // 将新状态添加到当前状态的子节点
                }

                currentState = newState; // 更新当前状态
                return newGrid;
            });
        },

        /**
         * Resets the grid to initial state
         */
        reset: () => {
            if (initialState) {
                currentState = initialState;
                userGrid.set(JSON.parse(JSON.stringify(initialState.grid)));
            }
        },

        /**
         * Applies strategy changes to the grid
         * @param {Array} grid - The current grid
         * @param {Array} changes - Array of changes to apply
         * @param {Object} candidatesStore - The candidates store
         * @returns {Array} Updated grid
         */
        applyStrategyChanges: (grid, changes, candidatesStore) => {
            return applyStrategyChanges(grid, changes, candidatesStore);
        }
    };
}

export const userGrid = createUserGrid();

/**
 * Derived store that tracks invalid cell positions
 * Checks rows, columns, and boxes for duplicate numbers
 */
export const invalidCells = derived(userGrid, $userGrid => {
    const _invalidCells = [];

    /**
     * Adds a cell position to invalid cells list
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     */
    const addInvalid = (x, y) => {
        const xy = x + ',' + y;
        if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
    };

    // Check all cells for validity
    for (let y = 0; y < SUDOKU_SIZE; y++) {
        for (let x = 0; x < SUDOKU_SIZE; x++) {

            const value = $userGrid[y][x];

            if (value) {
                for (let i = 0; i < SUDOKU_SIZE; i++) {
                    // Check the row
                    if (i !== x && $userGrid[y][i] === value) {
                        addInvalid(x, y);
                    }

                    // Check the column
                    if (i !== y && $userGrid[i][x] === value) {
                        addInvalid(x, i);
                    }
                }

                // Check the box
                const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
                const endY = startY + BOX_SIZE;
                const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
                const endX = startX + BOX_SIZE;
                for (let row = startY; row < endY; row++) {
                    for (let col = startX; col < endX; col++) {
                        if (row !== y && col !== x && $userGrid[row][col] === value) {
                            addInvalid(col, row);
                        }
                    }
                }
            }

        }
    }

    return _invalidCells;
}, []);


function checkInvalidCells($userGrid) {
    const _invalidCells = [];

    /**
     * Adds a cell position to invalid cells list
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     */
    const addInvalid = (x, y) => {
        const xy = x + ',' + y;
        if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
    };

    // Check all cells for validity
    for (let y = 0; y < SUDOKU_SIZE; y++) {
        for (let x = 0; x < SUDOKU_SIZE; x++) {
            const value = $userGrid[y][x];

            if (value) {
                for (let i = 0; i < SUDOKU_SIZE; i++) {
                    // Check the row
                    if (i!== x && $userGrid[y][i] === value) {
                        addInvalid(x, y);
                    }

                    // Check the column
                    if (i!== y && $userGrid[i][x] === value) {
                        addInvalid(x, i);
                    }
                }

                // Check the box
                const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
                const endY = startY + BOX_SIZE;
                const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
                const endX = startX + BOX_SIZE;
                for (let row = startY; row < endY; row++) {
                    for (let col = startX; col < endX; col++) {
                        if (row!== y && col!== x && $userGrid[row][col] === value) {
                            addInvalid(col, row);
                        }
                    }
                }
            }
        }
    }

    return _invalidCells;
}

function checkValidNumbers($userGrid, pos) {
    let x = pos.x, y = pos.y;
    let valid_numbers = new Array(10).fill(0);
    for (let value = 1; value <= 9; value++) {
        if (checkSingleNumbers($userGrid, x, y, value)) {
            valid_numbers[value]=1;
        }
    }
    return valid_numbers;
}

function checkSingleNumbers($userGrid, x,y,value) {
    for (let i = 0; i < SUDOKU_SIZE; i++) {
        // Check the row
        if (i!== x && $userGrid[y][i] === value) {
            return false;
        }
        // Check the column
        if (i!== y && $userGrid[i][x] === value) {
            return false;
        }
    }
    // Check the box
    const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
    const endY = startY + BOX_SIZE;
    const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
    const endX = startX + BOX_SIZE;
    for (let row = startY; row < endY; row++) {
        for (let col = startX; col < endX; col++) {
            if (row!== y && col!== x && $userGrid[row][col] === value) {
                return false;
            }
        }
    }
    return true;
}




// /**
//  * Creates a user-editable grid with undo/redo functionality
//  * @returns {Object} User grid store with history management
//  */
// function createUserGrid() {
//     // History management for undo/redo
//     let undoHistory = [];
//     let redoHistory = [];
//     const MAX_HISTORY_LENGTH = 10000;
//     let initialState = null;
//
//     // Initialize empty user grid
//     const userGrid = writable([
//         [0, 0, 0, 0, 0, 0, 0, 0, 0],
//         [0, 0, 0, 0, 0, 0, 0, 0, 0],
//         [0, 0, 0, 0, 0, 0, 0, 0, 0],
//         [0, 0, 0, 0, 0, 0, 0, 0, 0],
//         [0, 0, 0, 0, 0, 0, 0, 0, 0],
//         [0, 0, 0, 0, 0, 0, 0, 0, 0],
//         [0, 0, 0, 0, 0, 0, 0, 0, 0],
//         [0, 0, 0, 0, 0, 0, 0, 0, 0],
//         [0, 0, 0, 0, 0, 0, 0, 0, 0],
//     ]);
//
//     /**
//      * Subscribe to main grid changes to sync user grid
//      */
//     grid.subscribe($grid => {
//         let newGrid = [];
//         for (let y = 0; y < SUDOKU_SIZE; y++) {
//             newGrid[y] = [];
//             for (let x = 0; x < SUDOKU_SIZE; x++) {
//                 newGrid[y][x] = $grid[y][x];
//             }
//         }
//         initialState = JSON.parse(JSON.stringify(newGrid));
//         userGrid.set(newGrid);
//
//         undoHistory = [];
//         redoHistory = [];
//     });
//
//     // Subscribe to userGrid changes to update candidates
//     userGrid.subscribe($grid => {
//         candidates.update($store => ({
//             ...$store,
//             candidates: calculateAllCandidates($grid)
//         }));
//     });
//
//     return {
//         subscribe: userGrid.subscribe,
//
//         /**
//          * Sets a value at specified position and updates history
//          * @param {Object} pos - Position {x, y}
//          * @param {number} value - Number to set (1-9)
//          */
//         set: (pos, value) => {
//             userGrid.update($userGrid => {
//                 if (undoHistory.length >= MAX_HISTORY_LENGTH) {
//                     undoHistory.shift();
//                 }
//                 undoHistory.push(JSON.parse(JSON.stringify($userGrid)));
//
//                 redoHistory = [];
//
//                 $userGrid[pos.y][pos.x] = value;
//                 return $userGrid;
//             });
//         },
//
//         /**
//          * Undoes the last move if available
//          */
//         undo: () => {
//             if (undoHistory.length === 0) {
//                 return;
//             }
//             userGrid.update($userGrid => {
//                 redoHistory.push(JSON.parse(JSON.stringify($userGrid)));
//                 const previousState = undoHistory.pop();
//                 return previousState;
//             });
//         },
//
//         /**
//          * Redoes the last undone move if available
//          */
//         redo: () => {
//             if (redoHistory.length === 0) {
//                 return;
//             }
//             userGrid.update($userGrid => {
//                 undoHistory.push(JSON.parse(JSON.stringify($userGrid)));
//                 const nextState = redoHistory.pop();
//                 return nextState;
//             });
//         },
//
//         /**
//          * Applies a strategy at specified position and consumes a hint
//          * @param {Object} pos - Position {x, y}
//          * @param {Object} strategy - The strategy to apply
//          * @param {Object} candidatesStore - The candidates store
//          */
//         applyStrategy: (pos, strategy, candidatesStore) => {
//             hints.useHint();
//             console.log('Applying hint at ' + pos.x + ',' + pos.y);
//             console.log(strategy);
//
//             userGrid.update($userGrid => {
//                 if (undoHistory.length >= MAX_HISTORY_LENGTH) {
//                     undoHistory.shift();
//                 }
//                 undoHistory.push(JSON.parse(JSON.stringify($userGrid)));
//
//                 redoHistory = [];
//
//                 // 应用策略
//                 const changes = strategy.effect($userGrid);
//                 if (changes && changes.length > 0) {
//                     return applyStrategyChanges($userGrid, changes, candidatesStore);
//                 }
//
//                 return $userGrid;
//             });
//         },
//
//         /**
//          * Resets the grid to initial state
//          */
//         reset: () => {
//             if (initialState) {
//                 userGrid.set(JSON.parse(JSON.stringify(initialState)));
//                 undoHistory = [];
//                 redoHistory = [];
//             }
//         },
//
//         /**
//          * Applies strategy changes to the grid
//          * @param {Array} grid - The current grid
//          * @param {Array} changes - Array of changes to apply
//          * @param {Object} candidatesStore - The candidates store
//          * @returns {Array} Updated grid
//          */
//         applyStrategyChanges: (grid, changes, candidatesStore) => {
//             return applyStrategyChanges(grid, changes, candidatesStore);
//         }
//     };
// }
//
// // export const userGrid = createUserGrid();
// if (!newState) {
//     // 如果状态不存在，创建新节点
//     newState = new StateNode(newGrid, currentState);
//
//     if (checkInvalidCells(newGrid).length > 0){
//         newState.isInvalid = true;  //非法
//     }
//
//     stateMap.set(newStateKey, newState);
//
//     if (currentState) {
//         currentState.children=newState; // 将新状态添加到当前状态的子节点
//     }
// } else {
//     // 如果状态已存在，直接引用
//     if (currentState) {
//         currentState.children=newState; // 将已有状态添加到当前状态的子节点
//     }
// }