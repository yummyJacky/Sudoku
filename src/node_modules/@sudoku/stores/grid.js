/**
 * Sudoku Grid Management Module
 * This module provides functionality for managing both the initial Sudoku grid
 * and the user's playing grid with undo/redo capabilities.
 */

import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
import { hints } from './hints';

/**
 * Creates the initial Sudoku grid store
 * @returns {Object} Grid store with methods for grid manipulation
 */
function createGrid() {
    // Initialize empty 9x9 grid
    const grid = writable([
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ]);

    return {
        subscribe: grid.subscribe,

        /**
         * Generates a new Sudoku puzzle with specified difficulty
         * @param {number} difficulty - The difficulty level of the puzzle
         */
        generate(difficulty) {
            grid.set(generateSudoku(difficulty));
        },

        /**
         * Decodes a sencode string into a Sudoku grid
         * @param {string} sencode - Encoded Sudoku string
         */
        decodeSencode(sencode) {
            grid.set(decodeSencode(sencode));
        },

        /**
         * Sets grid from a flat array of 81 numbers
         * @param {number[]} numbers - Array of 81 numbers representing the grid
         */
        setFromArray(numbers) {
            if (!Array.isArray(numbers) || numbers.length !== 81) {
                throw new Error('Invalid grid array');
            }

            const newGrid = Array(9).fill(0).map(() => Array(9).fill(0));

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const value = numbers[row * 9 + col];

                    newGrid[row][col] = (value >= 0 && value <= 9) ? value : 0;
                }
            }

            grid.set(newGrid);
        },

        /**
         * Gets value at specified coordinates
         * @param {Array} gridStore - The grid array
         * @param {number} x - X coordinate
         * @param {number} y - Y coordinate
         * @returns {number} Value at coordinates
         */
        get(gridStore, x, y) {
            return gridStore[y][x];
        },

        /**
         * Gets the sencode representation of the grid
         * @param {Array} gridStore - The grid array
         * @returns {string} Encoded grid string
         */
        getSencode(gridStore) {
            return encodeSudoku(gridStore);
        },
    };
}

export const grid = createGrid();

/**
 * Creates a user-editable grid with undo/redo functionality
 * @returns {Object} User grid store with history management
 */
function createUserGrid() {
    // History management for undo/redo
    let undoHistory = [];
    let redoHistory = [];
    const MAX_HISTORY_LENGTH = 10000;
    let initialState = null;

    // Initialize empty user grid
    const userGrid = writable([
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ]);

    /**
     * Subscribe to main grid changes to sync user grid
     */
    grid.subscribe($grid => {
        let newGrid = [];
        for (let y = 0; y < SUDOKU_SIZE; y++) {
            newGrid[y] = [];
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                newGrid[y][x] = $grid[y][x];
            }
        }
        initialState = JSON.parse(JSON.stringify(newGrid));
        userGrid.set(newGrid);

        undoHistory = [];
        redoHistory = [];
    });

    return {
        subscribe: userGrid.subscribe,

        /**
         * Sets a value at specified position and updates history
         * @param {Object} pos - Position {x, y}
         * @param {number} value - Number to set (1-9)
         */
        set: (pos, value) => {
            userGrid.update($userGrid => {

                if (undoHistory.length >= MAX_HISTORY_LENGTH) {
                    undoHistory.shift();
                }
                undoHistory.push(JSON.parse(JSON.stringify($userGrid)));

                redoHistory = [];

                $userGrid[pos.y][pos.x] = value;
                return $userGrid;
            });
        },

        /**
         * Undoes the last move if available
         */
        undo: () => {
            if (undoHistory.length === 0) {
                return;
            }
            userGrid.update($userGrid => {

                redoHistory.push(JSON.parse(JSON.stringify($userGrid)));

                const previousState = undoHistory.pop();
                return previousState;
            });
        },

        /**
         * Redoes the last undone move if available
         */
        redo: () => {
            if (redoHistory.length === 0) {
                return;
            }
            userGrid.update($userGrid => {

                undoHistory.push(JSON.parse(JSON.stringify($userGrid)));

                const nextState = redoHistory.pop();
                return nextState;
            });
        },

        /**
         * Applies a hint at specified position using solver
         * @param {Object} pos - Position {x, y} to reveal
         */
        applyHint: (pos) => {
            hints.useHint();
            userGrid.update($userGrid => {

                if (undoHistory.length >= MAX_HISTORY_LENGTH) {
                    undoHistory.shift();
                }
                undoHistory.push(JSON.parse(JSON.stringify($userGrid)));

                redoHistory = [];

                const solvedSudoku = solveSudoku($userGrid);
                $userGrid[pos.y][pos.x] = solvedSudoku[pos.y][pos.x];
                return $userGrid;
            });
        },

        /**
         * Resets the grid to initial state
         */
        reset: () => {
            if (initialState) {
                userGrid.set(JSON.parse(JSON.stringify(initialState)));

                undoHistory = [];
                redoHistory = [];
            }
        },
    };
}

export const userGrid = createUserGrid();

/**
 * Derived store that tracks invalid cell positions
 * Checks rows, columns, and boxes for duplicate numbers
 */
export const invalidCells = derived(userGrid, $userGrid => {
    const _invalidCells = [];

    /**
     * Adds a cell position to invalid cells list
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     */
    const addInvalid = (x, y) => {
        const xy = x + ',' + y;
        if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
    };

    // Check all cells for validity
    for (let y = 0; y < SUDOKU_SIZE; y++) {
        for (let x = 0; x < SUDOKU_SIZE; x++) {

            const value = $userGrid[y][x];

            if (value) {
                for (let i = 0; i < SUDOKU_SIZE; i++) {
                    // Check the row
                    if (i !== x && $userGrid[y][i] === value) {
                        addInvalid(x, y);
                    }

                    // Check the column
                    if (i !== y && $userGrid[i][x] === value) {
                        addInvalid(x, i);
                    }
                }

                // Check the box
                const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
                const endY = startY + BOX_SIZE;
                const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
                const endX = startX + BOX_SIZE;
                for (let row = startY; row < endY; row++) {
                    for (let col = startX; col < endX; col++) {
                        if (row !== y && col !== x && $userGrid[row][col] === value) {
                            addInvalid(col, row);
                        }
                    }
                }
            }

        }
    }

    return _invalidCells;
}, []);