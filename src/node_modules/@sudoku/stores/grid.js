/**
 * Sudoku Grid Management Module
 * This module provides functionality for managing both the initial Sudoku grid
 * and the user's playing grid with undo/redo capabilities.
 */

import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
import { hints } from './hints';
import { candidates } from './candidates';

/**
 * Calculates all possible candidates for a cell
 * @param {Array} grid - The current grid
 * @param {number} row - Row index
 * @param {number} col - Column index
 * @returns {Array} Array of candidate numbers
 */
function calculateCellCandidates(grid, row, col) {
    if (grid[row][col] !== 0) {
        return [];
    }

    const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);

    // Check row
    for (let x = 0; x < 9; x++) {
        candidates.delete(grid[row][x]);
    }

    // Check column
    for (let y = 0; y < 9; y++) {
        candidates.delete(grid[y][col]);
    }

    // Check box
    const boxStartRow = Math.floor(row / 3) * 3;
    const boxStartCol = Math.floor(col / 3) * 3;
    for (let y = boxStartRow; y < boxStartRow + 3; y++) {
        for (let x = boxStartCol; x < boxStartCol + 3; x++) {
            candidates.delete(grid[y][x]);
        }
    }

    return Array.from(candidates);
}

/**
 * Calculates candidates for all cells in the grid
 * @param {Array} grid - The current grid
 * @returns {Object} Object containing candidates for each cell
 */
function calculateAllCandidates(grid) {
    const allCandidates = {};
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            const key = `${col},${row}`;
            allCandidates[key] = calculateCellCandidates(grid, row, col);
        }
    }
    return allCandidates;
}

/**
 * Creates the initial Sudoku grid store
 * @returns {Object} Grid store with methods for grid manipulation
 */
function createGrid() {
    // Initialize empty 9x9 grid
    const grid = writable([
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ]);

    return {
        subscribe: grid.subscribe,

        /**
         * Generates a new Sudoku puzzle with specified difficulty
         * @param {number} difficulty - The difficulty level of the puzzle
         */
        generate(difficulty) {
            grid.set(generateSudoku(difficulty));
        },

        /**
         * Decodes a sencode string into a Sudoku grid
         * @param {string} sencode - Encoded Sudoku string
         */
        decodeSencode(sencode) {
            grid.set(decodeSencode(sencode));
        },

        /**
         * Sets grid from a flat array of 81 numbers
         * @param {number[]} numbers - Array of 81 numbers representing the grid
         */
        setFromArray(numbers) {
            if (!Array.isArray(numbers) || numbers.length !== 81) {
                throw new Error('Invalid grid array');
            }

            const newGrid = Array(9).fill(0).map(() => Array(9).fill(0));

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const value = numbers[row * 9 + col];

                    newGrid[row][col] = (value >= 0 && value <= 9) ? value : 0;
                }
            }

            grid.set(newGrid);
        },

        /**
         * Gets value at specified coordinates
         * @param {Array} gridStore - The grid array
         * @param {number} x - X coordinate
         * @param {number} y - Y coordinate
         * @returns {number} Value at coordinates
         */
        get(gridStore, x, y) {
            return gridStore[y][x];
        },

        /**
         * Gets the sencode representation of the grid
         * @param {Array} gridStore - The grid array
         * @returns {string} Encoded grid string
         */
        getSencode(gridStore) {
            return encodeSudoku(gridStore);
        },
    };
}

export const grid = createGrid();

/**
 * Applies strategy changes to the grid
 * @param {Array} grid - The current grid
 * @param {Array} changes - Array of changes to apply
 * @param {Object} candidatesStore - The candidates store
 * @returns {Array} Updated grid
 */
function applyStrategyChanges(grid, changes, candidatesStore) {
    const newGrid = JSON.parse(JSON.stringify(grid));
    
    for (const change of changes) {
        if (change.type === 'set_value') {
            newGrid[change.row][change.col] = change.digit;
        } else if (change.type === 'highlight_candidate') {
            // 高亮候选值
            candidatesStore.highlightCandidate(
                { x: change.col, y: change.row },
                change.digit,
                change.highlightType
            );
        } else if (change.type === 'remove_candidate') {
            // 删除候选值
            const key = `${change.col},${change.row}`;
            candidatesStore.update($store => {
                const candidates = { ...$store.candidates };
                if (candidates[key]) {
                    candidates[key] = candidates[key].filter(d => d !== change.digit);
                    if (candidates[key].length === 0) {
                        delete candidates[key];
                    }
                }
                return { ...$store, candidates };
            });
        }
    }
    
    return newGrid;
}

/**
 * Creates a user-editable grid with undo/redo functionality
 * @returns {Object} User grid store with history management
 */
function createUserGrid() {
    // History management for undo/redo
    let undoHistory = [];
    let redoHistory = [];
    const MAX_HISTORY_LENGTH = 10000;
    let initialState = null;

    // Initialize empty user grid
    const userGrid = writable([
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ]);

    /**
     * Subscribe to main grid changes to sync user grid
     */
    grid.subscribe($grid => {
        let newGrid = [];
        for (let y = 0; y < SUDOKU_SIZE; y++) {
            newGrid[y] = [];
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                newGrid[y][x] = $grid[y][x];
            }
        }
        initialState = JSON.parse(JSON.stringify(newGrid));
        userGrid.set(newGrid);

        undoHistory = [];
        redoHistory = [];
    });

    // Subscribe to userGrid changes to update candidates
    userGrid.subscribe($grid => {
        candidates.update($store => ({
            ...$store,
            candidates: calculateAllCandidates($grid)
        }));
    });

    return {
        subscribe: userGrid.subscribe,

        /**
         * Sets a value at specified position and updates history
         * @param {Object} pos - Position {x, y}
         * @param {number} value - Number to set (1-9)
         */
        set: (pos, value) => {
            userGrid.update($userGrid => {
                if (undoHistory.length >= MAX_HISTORY_LENGTH) {
                    undoHistory.shift();
                }
                undoHistory.push(JSON.parse(JSON.stringify($userGrid)));

                redoHistory = [];

                $userGrid[pos.y][pos.x] = value;
                return $userGrid;
            });
        },

        /**
         * Undoes the last move if available
         */
        undo: () => {
            if (undoHistory.length === 0) {
                return;
            }
            userGrid.update($userGrid => {
                redoHistory.push(JSON.parse(JSON.stringify($userGrid)));
                const previousState = undoHistory.pop();
                return previousState;
            });
        },

        /**
         * Redoes the last undone move if available
         */
        redo: () => {
            if (redoHistory.length === 0) {
                return;
            }
            userGrid.update($userGrid => {
                undoHistory.push(JSON.parse(JSON.stringify($userGrid)));
                const nextState = redoHistory.pop();
                return nextState;
            });
        },

        /**
         * Applies a strategy at specified position and consumes a hint
         * @param {Object} pos - Position {x, y}
         * @param {Object} strategy - The strategy to apply
         * @param {Object} candidatesStore - The candidates store
         */
        applyStrategy: (pos, strategy, candidatesStore) => {
            hints.useHint();
            console.log('Applying hint at ' + pos.x + ',' + pos.y);
            console.log(strategy);
            
            userGrid.update($userGrid => {
                if (undoHistory.length >= MAX_HISTORY_LENGTH) {
                    undoHistory.shift();
                }
                undoHistory.push(JSON.parse(JSON.stringify($userGrid)));

                redoHistory = [];

                // 应用策略
                const changes = strategy.effect($userGrid);
                if (changes && changes.length > 0) {
                    return applyStrategyChanges($userGrid, changes, candidatesStore);
                }
                
                return $userGrid;
            });
        },

        /**
         * Resets the grid to initial state
         */
        reset: () => {
            if (initialState) {
                userGrid.set(JSON.parse(JSON.stringify(initialState)));
                undoHistory = [];
                redoHistory = [];
            }
        },

        /**
         * Applies strategy changes to the grid
         * @param {Array} grid - The current grid
         * @param {Array} changes - Array of changes to apply
         * @param {Object} candidatesStore - The candidates store
         * @returns {Array} Updated grid
         */
        applyStrategyChanges: (grid, changes, candidatesStore) => {
            return applyStrategyChanges(grid, changes, candidatesStore);
        }
    };
}

export const userGrid = createUserGrid();

/**
 * Derived store that tracks invalid cell positions
 * Checks rows, columns, and boxes for duplicate numbers
 */
export const invalidCells = derived(userGrid, $userGrid => {
    const _invalidCells = [];

    /**
     * Adds a cell position to invalid cells list
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     */
    const addInvalid = (x, y) => {
        const xy = x + ',' + y;
        if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
    };

    // Check all cells for validity
    for (let y = 0; y < SUDOKU_SIZE; y++) {
        for (let x = 0; x < SUDOKU_SIZE; x++) {

            const value = $userGrid[y][x];

            if (value) {
                for (let i = 0; i < SUDOKU_SIZE; i++) {
                    // Check the row
                    if (i !== x && $userGrid[y][i] === value) {
                        addInvalid(x, y);
                    }

                    // Check the column
                    if (i !== y && $userGrid[i][x] === value) {
                        addInvalid(x, i);
                    }
                }

                // Check the box
                const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
                const endY = startY + BOX_SIZE;
                const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
                const endX = startX + BOX_SIZE;
                for (let row = startY; row < endY; row++) {
                    for (let col = startX; col < endX; col++) {
                        if (row !== y && col !== x && $userGrid[row][col] === value) {
                            addInvalid(col, row);
                        }
                    }
                }
            }

        }
    }

    return _invalidCells;
}, []);