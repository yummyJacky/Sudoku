import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
import { hints } from './hints';

function createGrid() {
    const grid = writable([
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ]);

    return {
        subscribe: grid.subscribe,

        generate(difficulty) {
            grid.set(generateSudoku(difficulty));
        },

        decodeSencode(sencode) {
            grid.set(decodeSencode(sencode));
        },

        setFromArray(numbers) {
            if (!Array.isArray(numbers) || numbers.length !== 81) {
                throw new Error('Invalid grid array');
            }

            const newGrid = Array(9).fill(0).map(() => Array(9).fill(0));
            
            // 将一维数组转换为9x9网格
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const value = numbers[row * 9 + col];
                    // 0表示空格子
                    newGrid[row][col] = (value >= 0 && value <= 9) ? value : 0;
                }
            }
            
            grid.set(newGrid);
        },

        get(gridStore, x, y) {
            return gridStore[y][x];
        },

        getSencode(gridStore) {
            return encodeSudoku(gridStore);
        },
    };
}

export const grid = createGrid();


function createUserGrid() {
    // 添加历史状态数组和重做历史数组
    let undoHistory = [];
    let redoHistory = [];
    const MAX_HISTORY_LENGTH = 10000;
    let initialState = null;

    const userGrid = writable([
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ]);

    grid.subscribe($grid => {
        let newGrid = [];
        for (let y = 0; y < SUDOKU_SIZE; y++) {
            newGrid[y] = [];
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                newGrid[y][x] = $grid[y][x];
            }
        }
        initialState = JSON.parse(JSON.stringify(newGrid));
        userGrid.set(newGrid);
        // 清空所有历史记录，因为这是新的游戏开始
        undoHistory = [];
        redoHistory = [];
    });

    return {
        subscribe: userGrid.subscribe,

        set: (pos, value) => {
            userGrid.update($userGrid => {
                // 在修改之前保存当前状态到撤销历史
                if (undoHistory.length >= MAX_HISTORY_LENGTH) {
                    undoHistory.shift();
                }
                undoHistory.push(JSON.parse(JSON.stringify($userGrid)));
                // 清空重做历史，因为有了新的操作
                redoHistory = [];
                
                $userGrid[pos.y][pos.x] = value;
                return $userGrid;
            });
        },

        undo: () => {
            if (undoHistory.length === 0) {
                return; // 如果没有撤销历史记录，不做任何改变
            }
            userGrid.update($userGrid => {
                // 保存当前状态到重做历史
                redoHistory.push(JSON.parse(JSON.stringify($userGrid)));
                // 恢复上一个状态
                const previousState = undoHistory.pop();
                return previousState;
            });
        },

        redo: () => {
            if (redoHistory.length === 0) {
                return; // 如果没有重做历史记录，不做任何改变
            }
            userGrid.update($userGrid => {
                // 保存当前状态到撤销历史
                undoHistory.push(JSON.parse(JSON.stringify($userGrid)));
                // 恢复下一个状态
                const nextState = redoHistory.pop();
                return nextState;
            });
        },

        applyHint: (pos) => {
            hints.useHint();
            userGrid.update($userGrid => {
                // 在应用提示之前保存当前状态
                if (undoHistory.length >= MAX_HISTORY_LENGTH) {
                    undoHistory.shift();
                }
                undoHistory.push(JSON.parse(JSON.stringify($userGrid)));
                // 清空重做历史，因为有了新的操作
                redoHistory = [];

                const solvedSudoku = solveSudoku($userGrid);
                $userGrid[pos.y][pos.x] = solvedSudoku[pos.y][pos.x];
                return $userGrid;
            });
        },

        reset: () => {
            if (initialState) {
                userGrid.set(JSON.parse(JSON.stringify(initialState)));
                // 清空所有历史记录
                undoHistory = [];
                redoHistory = [];
            }
        },
    };
}

export const userGrid = createUserGrid();

export const invalidCells = derived(userGrid, $userGrid => {
	const _invalidCells = [];

	const addInvalid = (x, y) => {
		const xy = x + ',' + y;
		if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
	};

	for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {

			const value = $userGrid[y][x];

			if (value) {
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					// Check the row
					if (i !== x && $userGrid[y][i] === value) {
						addInvalid(x, y);
					}

					// Check the column
					if (i !== y && $userGrid[i][x] === value) {
						addInvalid(x, i);
					}
				}

				// Check the box
				const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
				const endY = startY + BOX_SIZE;
				const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
				const endX = startX + BOX_SIZE;
				for (let row = startY; row < endY; row++) {
					for (let col = startX; col < endX; col++) {
						if (row !== y && col !== x && $userGrid[row][col] === value) {
							addInvalid(col, row);
						}
					}
				}
			}

		}
	}

	return _invalidCells;
}, []);