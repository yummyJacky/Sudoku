import { writable } from 'svelte/store';

// 添加候选数管理的工具函数
export const CandidateManager = {
    // 获取单元格的候选数
    getCandidates(grid, row, col) {
        if (grid[row][col] !== 0) return [];
        const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
        
        // 检查行
        for (let c = 0; c < 9; c++) {
            if (grid[row][c] !== 0) candidates.delete(grid[row][c]);
        }
        
        // 检查列
        for (let r = 0; r < 9; r++) {
            if (grid[r][col] !== 0) candidates.delete(grid[r][col]);
        }
        
        // 检查3x3宫格
        const boxRow = Math.floor(row / 3) * 3;
        const boxCol = Math.floor(col / 3) * 3;
        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
                if (grid[boxRow + r][boxCol + c] !== 0) {
                    candidates.delete(grid[boxRow + r][boxCol + c]);
                }
            }
        }
        
        return Array.from(candidates);
    },

    // 获取整个网格的候选数
    getGridCandidates(grid) {
        const candidates = Array(9).fill().map(() => 
            Array(9).fill().map(() => []));
        
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (grid[row][col] === 0) {
                    candidates[row][col] = this.getCandidates(grid, row, col);
                }
            }
        }
        
        return candidates;
    }
};

// 添加X-Wing策略的实现
export const XWingStrategy = {
    // 查找行X-Wing模式
    findRowXWing(grid, candidatesMap) {
        const patterns = [];
        // 遍历所有可能的数字1-9
        for (let digit = 1; digit <= 9; digit++) {
            // 记录每行中数字出现的位置
            const rowPositions = Array(9).fill().map(() => []);
            
            // 遍历每一行，找出候选数digit出现的列位置
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const key = `${col},${row}`;
                    if (candidatesMap[key] && candidatesMap[key].includes(digit)) {
                        rowPositions[row].push(col);
                    }
                }
            }
            
            // 查找具有相同两个位置的行
            for (let row1 = 0; row1 < 8; row1++) {
                // 确保第一行恰好有两个候选位置
                if (rowPositions[row1].length !== 2) continue;
                
                for (let row2 = row1 + 1; row2 < 9; row2++) {
                    // 确保第二行也恰好有两个候选位置，且位置与第一行相同
                    if (rowPositions[row2].length === 2 &&
                        rowPositions[row1][0] === rowPositions[row2][0] &&
                        rowPositions[row1][1] === rowPositions[row2][1]) {
                        
                        // 找到X-Wing模式，生成效果
                        const col1 = rowPositions[row1][0];
                        const col2 = rowPositions[row1][1];
                        const changes = [];
                        
                        // 检查其他行的这两列是否有相同的候选数，如果有则可以删除
                        for (let r = 0; r < 9; r++) {
                            if (r !== row1 && r !== row2) {
                                const key1 = `${col1},${r}`;
                                const key2 = `${col2},${r}`;
                                 
                                if (candidatesMap[key1] && candidatesMap[key1].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: r,
                                        col: col1,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    });
                                }
                                 
                                if (candidatesMap[key2] && candidatesMap[key2].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: r,
                                        col: col2,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    });
                                }
                            }
                        }
                        
                        // 高亮X-Wing的四个角
                        changes.push(
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            }
                        );
                        
                        if (changes.length > 4) { // 如果除了四个角外还有其他要删除的候选数
                            patterns.push({
                                digit,
                                changes
                            });
                        }
                    }
                }
            }
        }
        return patterns;
    },

    // 查找列X-Wing模式
    findColXWing(grid, candidatesMap) {
        const patterns = [];
        // 遍历所有可能的数字1-9
        for (let digit = 1; digit <= 9; digit++) {
            // 记录每列中数字出现的位置
            const colPositions = Array(9).fill().map(() => []);
            
            // 遍历每一列，找出候选数digit出现的行位置
            for (let col = 0; col < 9; col++) {
                for (let row = 0; row < 9; row++) {
                    const key = `${col},${row}`;
                    if (candidatesMap[key] && candidatesMap[key].includes(digit)) {
                        colPositions[col].push(row);
                    }
                }
            }
            
            // 查找具有相同两个位置的列
            for (let col1 = 0; col1 < 8; col1++) {
                // 确保第一列恰好有两个候选位置
                if (colPositions[col1].length !== 2) continue;
                
                for (let col2 = col1 + 1; col2 < 9; col2++) {
                    // 确保第二列也恰好有两个候选位置，且位置与第一列相同
                    if (colPositions[col2].length === 2 &&
                        colPositions[col1][0] === colPositions[col2][0] &&
                        colPositions[col1][1] === colPositions[col2][1]) {
                        
                        // 找到X-Wing模式，生成效果
                        const row1 = colPositions[col1][0];
                        const row2 = colPositions[col1][1];
                        const changes = [];
                        
                        // 检查其他列的这两行是否有相同的候选数，如果有则可以删除
                        for (let c = 0; c < 9; c++) {
                            if (c !== col1 && c !== col2) {
                                const key1 = `${c},${row1}`;
                                const key2 = `${c},${row2}`;
                                 
                                if (candidatesMap[key1] && candidatesMap[key1].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: row1,
                                        col: c,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    });
                                }
                                 
                                if (candidatesMap[key2] && candidatesMap[key2].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: row2,
                                        col: c,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    });
                                }
                            }
                        }
                        
                        // 高亮X-Wing的四个角
                        changes.push(
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            }
                        );
                        
                        if (changes.length > 4) { // 如果除了四个角外还有其他要删除的候选数
                            patterns.push({
                                digit,
                                changes
                            });
                        }
                    }
                }
            }
        }
        return patterns;
    }
};

// 添加XY-Chain策略的实现
export const XYChainStrategy = {
    // 找到所有只有两个候选数的格子
    findBivalueCells(grid, candidatesMap) {
        const bivalueCells = [];
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const key = `${col},${row}`;
                const candidates = candidatesMap[key];
                if (candidates && candidates.length === 2) {
                    bivalueCells.push({
                        key,
                        row,
                        col,
                        candidates: candidates
                    });
                }
            }
        }
        return bivalueCells;
    },

    // 检查两个格子是否可以连接（共享一个候选数）
    canConnect(cell1, cell2) {
        return cell1.candidates.some(n => cell2.candidates.includes(n));
    },

    // 获取两个格子共享的候选数
    getSharedCandidate(cell1, cell2) {
        return cell1.candidates.find(n => cell2.candidates.includes(n));
    },

    // 检查两个格子是否在同一区域（行、列或宫格）
    inSameUnit(cell1, cell2) {
        return cell1.row === cell2.row || // 同行
               cell1.col === cell2.col || // 同列
               (Math.floor(cell1.row/3) === Math.floor(cell2.row/3) && // 同宫格
                Math.floor(cell1.col/3) === Math.floor(cell2.col/3));
    },

    // 寻找XY-Chain
    findChains(bivalueCells) {
        const chains = [];
        
        // 对每个双数格子尝试构建链
        for (let startIdx = 0; startIdx < bivalueCells.length; startIdx++) {
            const visited = new Set([startIdx]);
            const chain = [bivalueCells[startIdx]];
            
            this.buildChain(bivalueCells, chain, visited, chains);
        }
        
        return chains;
    },

    // 递归构建链
    buildChain(bivalueCells, currentChain, visited, allChains) {
        const lastCell = currentChain[currentChain.length - 1];
        
        // 如果链长度大于2，检查是否形成有效的XY-Chain
        if (currentChain.length > 2) {
            const startCell = currentChain[0];
            const endCell = lastCell;
            
            // 检查首尾是否有相同的候选数
            const startEndShared = this.getSharedCandidate(startCell, endCell);
            if (startEndShared) {
                // 确保链是交替的（相邻节点共享一个候选数）
                let isValid = true;
                for (let i = 0; i < currentChain.length - 1; i++) {
                    if (!this.canConnect(currentChain[i], currentChain[i + 1])) {
                        isValid = false;
                        break;
                    }
                }
                if (isValid) {
                    allChains.push([...currentChain]);
                }
            }
        }
        
        // 继续构建链
        for (let i = 0; i < bivalueCells.length; i++) {
            if (!visited.has(i)) {
                const nextCell = bivalueCells[i];
                
                // 检查是否可以连接到链上
                if (this.canConnect(lastCell, nextCell)) {
                    visited.add(i);
                    currentChain.push(nextCell);
                    this.buildChain(bivalueCells, currentChain, visited, allChains);
                    currentChain.pop();
                    visited.delete(i);
                }
            }
        }
    }
};

// 数独策略枚举
export const STRATEGIES = {
    BASIC_ELIMINATION: {
        name: 'simple strategy',
        description: '检查同行、同列和同宫格中的数字，排除已经使用的数字',
        effect: (grid) => {
            console.log('使用基本消除策略');
            return [];
        },
    },
    X_WING: {
        name: 'X-Wing',
        description: '当两行（或两列）中，某个候选数仅出现在相同的两列（或两行）时，这四个单元格形成X-Wing结构。此时，可以排除其他行或列中相同位置的该候选数。',
        effect: (grid) => {
            // 获取当前的候选数
            const candidatesMap = {};
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) {
                        const candidates = [];
                        for (let num = 1; num <= 9; num++) {
                            let canPlace = true;
                            // 检查行
                            for (let x = 0; x < 9; x++) {
                                if (grid[row][x] === num) {
                                    canPlace = false;
                                    break;
                                }
                            }
                            // 检查列
                            if (canPlace) {
                                for (let y = 0; y < 9; y++) {
                                    if (grid[y][col] === num) {
                                        canPlace = false;
                                        break;
                                    }
                                }
                            }
                            // 检查3x3方格
                            if (canPlace) {
                                const boxRow = Math.floor(row / 3) * 3;
                                const boxCol = Math.floor(col / 3) * 3;
                                for (let y = boxRow; y < boxRow + 3; y++) {
                                    for (let x = boxCol; x < boxCol + 3; x++) {
                                        if (grid[y][x] === num) {
                                            canPlace = false;
                                            break;
                                        }
                                    }
                                    if (!canPlace) break;
                                }
                            }
                            if (canPlace) {
                                candidates.push(num);
                            }
                        }
                        if (candidates.length > 0) {
                            candidatesMap[`${col},${row}`] = candidates;
                        }
                    }
                }
            }

            // 查找X-Wing模式
            const rowPatterns = XWingStrategy.findRowXWing(grid, candidatesMap);
            const colPatterns = XWingStrategy.findColXWing(grid, candidatesMap);
            
            // 返回找到的第一个有效模式
            const allPatterns = [...rowPatterns, ...colPatterns];
            if (allPatterns.length > 0) {
                return allPatterns[0].changes;
            }
            
            return [];
        }
    },
    LAST_REMAINING_1: {
        name: 'last remaining',
        description: '从未使用的数字中选择一个',
        effect: (grid) => {
            console.log('使用最后剩余策略');
            return [];
        },
    },
    SINGLE_CHOICE: {
        name: 'single choice',
        description: '填入唯一可能的数字',
        effect: (grid) => {
            console.log('使用单选策略');
            return [];
        },
    },
    XY_CHAIN: {
        name: 'XY-Chain',
        description: '通过连接只有两个候选数的格子形成链，当链的首尾有相同候选数时，可以排除某些候选数。',
        effect(grid) {
            // 获取候选数映射
            const candidatesMap = {};
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) {
                        const key = `${col},${row}`;
                        candidatesMap[key] = CandidateManager.getCandidates(grid, row, col);
                    }
                }
            }
            
            // 找到所有双数格子
            const bivalueCells = XYChainStrategy.findBivalueCells(grid, candidatesMap);
            
            // 寻找所有有效的XY-Chain
            const chains = XYChainStrategy.findChains(bivalueCells);
            
            const changes = [];
            
            // 处理找到的链
            for (const chain of chains) {
                // 获取链的首尾共享的候选数
                const startCell = chain[0];
                const endCell = chain[chain.length - 1];
                const sharedCandidate = XYChainStrategy.getSharedCandidate(startCell, endCell);
                
                // 高亮显示链
                for (let i = 0; i < chain.length; i++) {
                    const cell = chain[i];
                    
                    // 高亮当前格子的候选数
                    cell.candidates.forEach(digit => {
                        changes.push({
                            type: 'highlight_candidate',
                            row: cell.row,
                            col: cell.col,
                            digit,
                            highlightType: 'xy_chain'
                        });
                    });
                }
                
                // 标记可以排除的候选数
                // 检查所有可能看到链两端的格子
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        // 跳过链上的格子
                        if (chain.some(cell => cell.row === row && cell.col === col)) {
                            continue;
                        }
                        
                        // 如果这个格子可以同时看到链的两端
                        const canSeeStart = XYChainStrategy.inSameUnit({row, col}, startCell);
                        const canSeeEnd = XYChainStrategy.inSameUnit({row, col}, endCell);
                        
                        if (canSeeStart && canSeeEnd) {
                            const key = `${col},${row}`;
                            if (candidatesMap[key] && candidatesMap[key].includes(sharedCandidate)) {
                                changes.push({
                                    type: 'highlight_candidate',
                                    row,
                                    col,
                                    digit: sharedCandidate,
                                    highlightType: 'eliminated'
                                });
                            }
                        }
                    }
                }
            }
            
            return changes;
        }
    }
};

// 创建策略提示 store
function createStrategyHint() {
    const store = writable({
        strategy: STRATEGIES.BASIC_ELIMINATION,  // 设置默认策略
        position: null
    });

    return {
        subscribe: store.subscribe,
        setHint: (strategy, position) => {
            store.update(() => ({
                strategy: STRATEGIES[strategy] || STRATEGIES.BASIC_ELIMINATION,
                position
            }));
        },
        clear: () => {
            store.update(() => ({
                strategy: STRATEGIES.BASIC_ELIMINATION,  // 重置为默认策略
                position: null
            }));
        }
    };
}

export const strategyHint = createStrategyHint();
