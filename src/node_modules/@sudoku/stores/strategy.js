import { writable } from 'svelte/store';
import { candidates } from '@sudoku/stores/candidates';

// 添加候选数管理的工具函数
export const CandidateManager = {
    // 获取单元格的候选数
    getCandidates(grid, row, col) {
        if (grid[row][col] !== 0) return [];
        const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);

        // 检查行
        for (let c = 0; c < 9; c++) {
            if (grid[row][c] !== 0) candidates.delete(grid[row][c]);
        }

        // 检查列
        for (let r = 0; r < 9; r++) {
            if (grid[r][col] !== 0) candidates.delete(grid[r][col]);
        }

        // 检查3x3宫格
        const boxRow = Math.floor(row / 3) * 3;
        const boxCol = Math.floor(col / 3) * 3;
        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
                if (grid[boxRow + r][boxCol + c] !== 0) {
                    candidates.delete(grid[boxRow + r][boxCol + c]);
                }
            }
        }

        return Array.from(candidates);
    },

    // 获取整个网格的候选数
    getGridCandidates(grid) {
        const candidates = Array(9).fill().map(() =>
            Array(9).fill().map(() => []));

        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (grid[row][col] === 0) {
                    candidates[row][col] = this.getCandidates(grid, row, col);
                }
            }
        }

        return candidates;
    }
};

// 添加XY-Wing策略的实现
export const XYWingStrategy = {
    // 找到所有只有两个候选数的格子
    findBivalueCells(grid, candidatesMap) {
        const bivalueCells = [];
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const key = `${col},${row}`;
                if (grid[row][col] === 0 && candidatesMap[key] && candidatesMap[key].length === 2) {
                    bivalueCells.push({
                        row,
                        col,
                        candidates: candidatesMap[key]
                    });
                }
            }
        }
        return bivalueCells;
    },

    // 检查两个格子是否在同一个单元（行、列或宫格）内
    inSameUnit(cell1, cell2) {
        return cell1.row === cell2.row || 
               cell1.col === cell2.col || 
               (Math.floor(cell1.row / 3) === Math.floor(cell2.row / 3) && 
                Math.floor(cell1.col / 3) === Math.floor(cell2.col / 3));
    },

    // 获取两个格子共享的候选数
    getSharedCandidate(cell1, cell2) {
        return cell1.candidates.find(c => cell2.candidates.includes(c));
    },

    // 寻找XY-Wing结构
    findXYWings(bivalueCells) {
        const wings = [];
        // 遍历所有双值格找到可能的pivot
        for (let i = 0; i < bivalueCells.length; i++) {
            const pivot = bivalueCells[i];
            // 遍历其他格子找到可能的wing1和wing2
            for (let j = 0; j < bivalueCells.length; j++) {
                if (j === i) continue;
                const wing1 = bivalueCells[j];
                if (!this.inSameUnit(pivot, wing1)) continue;
                const sharedCandidate1 = this.getSharedCandidate(pivot, wing1);
                if (!sharedCandidate1) continue;

                for (let k = 0; k < bivalueCells.length; k++) {
                    if (k === i || k === j) continue;
                    const wing2 = bivalueCells[k];
                    if (!this.inSameUnit(pivot, wing2)) continue;
                    const sharedCandidate2 = this.getSharedCandidate(pivot, wing2);
                    if (!sharedCandidate2 || sharedCandidate1 === sharedCandidate2) continue;

                    // 检查wing1和wing2是否有相同的非共享候选数
                    const wing1NonShared = wing1.candidates.find(c => c !== sharedCandidate1);
                    const wing2NonShared = wing2.candidates.find(c => c !== sharedCandidate2);
                    if (wing1NonShared === wing2NonShared) {
                        wings.push({
                            pivot,
                            wing1,
                            wing2,
                            elimination: wing1NonShared
                        });
                    }
                }
            }
        }
        return wings;
    }
};

// 添加X-Wing策略的实现
export const XWingStrategy = {
    // 查找行X-Wing模式
    findRowXWing(grid, candidatesMap) {
        const patterns = [];
        // 遍历所有可能的数字1-9
        for (let digit = 1; digit <= 9; digit++) {
            // 记录每行中数字出现的位置
            const rowPositions = Array(9).fill().map(() => []);

            // 遍历每一行，找出候选数digit出现的列位置
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const key = `${col},${row}`;
                    if (candidatesMap[key] && candidatesMap[key].includes(digit)) {
                        rowPositions[row].push(col);
                    }
                }
            }

            // 查找具有相同两个位置的行
            for (let row1 = 0; row1 < 8; row1++) {
                // 确保第一行恰好有两个候选位置
                if (rowPositions[row1].length !== 2) continue;

                for (let row2 = row1 + 1; row2 < 9; row2++) {
                    // 确保第二行也恰好有两个候选位置，且位置与第一行相同
                    if (rowPositions[row2].length === 2 &&
                        rowPositions[row1][0] === rowPositions[row2][0] &&
                        rowPositions[row1][1] === rowPositions[row2][1]) {

                        // 找到X-Wing模式，生成效果
                        const col1 = rowPositions[row1][0];
                        const col2 = rowPositions[row1][1];
                        const changes = [];

                        // 检查其他行的这两列是否有相同的候选数，如果有则可以删除
                        for (let r = 0; r < 9; r++) {
                            if (r !== row1 && r !== row2) {
                                const key1 = `${col1},${r}`;
                                const key2 = `${col2},${r}`;

                                if (candidatesMap[key1] && candidatesMap[key1].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: r,
                                        col: col1,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    });
                                }

                                if (candidatesMap[key2] && candidatesMap[key2].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: r,
                                        col: col2,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    });
                                }
                            }
                        }

                        // 高亮X-Wing的四个角
                        changes.push(
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            }
                        );

                        if (changes.length > 4) { // 如果除了四个角外还有其他要删除的候选数
                            patterns.push({
                                digit,
                                changes
                            });
                        }
                    }
                }
            }
        }
        return patterns;
    },

    // 查找列X-Wing模式
    findColXWing(grid, candidatesMap) {
        const patterns = [];
        // 遍历所有可能的数字1-9
        for (let digit = 1; digit <= 9; digit++) {
            // 记录每列中数字出现的位置
            const colPositions = Array(9).fill().map(() => []);

            // 遍历每一列，找出候选数digit出现的行位置
            for (let col = 0; col < 9; col++) {
                for (let row = 0; row < 9; row++) {
                    const key = `${col},${row}`;
                    if (candidatesMap[key] && candidatesMap[key].includes(digit)) {
                        colPositions[col].push(row);
                    }
                }
            }

            // 查找具有相同两个位置的列
            for (let col1 = 0; col1 < 8; col1++) {
                // 确保第一列恰好有两个候选位置
                if (colPositions[col1].length !== 2) continue;

                for (let col2 = col1 + 1; col2 < 9; col2++) {
                    // 确保第二列也恰好有两个候选位置，且位置与第一列相同
                    if (colPositions[col2].length === 2 &&
                        colPositions[col1][0] === colPositions[col2][0] &&
                        colPositions[col1][1] === colPositions[col2][1]) {

                        // 找到X-Wing模式，生成效果
                        const row1 = colPositions[col1][0];
                        const row2 = colPositions[col1][1];
                        const changes = [];

                        // 检查其他列的这两行是否有相同的候选数，如果有则可以删除
                        for (let c = 0; c < 9; c++) {
                            if (c !== col1 && c !== col2) {
                                const key1 = `${c},${row1}`;
                                const key2 = `${c},${row2}`;

                                if (candidatesMap[key1] && candidatesMap[key1].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: row1,
                                        col: c,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    });
                                }

                                if (candidatesMap[key2] && candidatesMap[key2].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: row2,
                                        col: c,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    });
                                }
                            }
                        }

                        // 高亮X-Wing的四个角
                        changes.push(
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            }
                        );

                        if (changes.length > 4) { // 如果除了四个角外还有其他要删除的候选数
                            patterns.push({
                                digit,
                                changes
                            });
                        }
                    }
                }
            }
        }
        return patterns;
    }
};

// 添加Hidden Single策略的实现
export const HiddenSingleStrategy = {
    // 遍历某一行、列或宫格，查找Hidden Single
    findHiddenSingles(grid, candidatesMap) {
        const hiddenSingles = new Set(); // 使用Set避免重复
        // console.log('开始查找Hidden Singles...');

        // 遍历所有行、列和宫格
        for (let unitType of ["row", "col", "box"]) {
            for (let index = 0; index < 9; index++) {
                // console.log(`检查${unitType} ${index}`);
                const cells = this.getUnitCells(grid, unitType, index, candidatesMap);
                const candidateOccurrences = this.countCandidateOccurrences(cells);

                // console.log('候选数出现次数:', candidateOccurrences);

                // 找到出现次数为1的候选数字，并记录
                for (let [candidate, count] of Object.entries(candidateOccurrences)) {
                    if (count === 1) {
                        // console.log(`在${unitType} ${index}中找到Hidden Single: 数字${candidate}`);
                        const targetCell = cells.find(cell =>
                            cell.candidates.includes(Number(candidate))
                        );
                        if (targetCell) {
                            // console.log(`位置: 行${targetCell.row}, 列${targetCell.col}`);
                            const key = JSON.stringify({
                                row: targetCell.row,
                                col: targetCell.col,
                                candidate: Number(candidate)
                            });
                            hiddenSingles.add(key);
                        }
                    }
                }
            }
        }

        const result = Array.from(hiddenSingles).map(key => JSON.parse(key));
        // console.log('找到的所有Hidden Singles:', result);
        return result;
    },

    // 获取某一行、列或宫格的格子
    getUnitCells(grid, unitType, index, candidatesMap) {
        const cells = [];
        for (let i = 0; i < 9; i++) {
            let row, col;

            if (unitType === "row") {
                row = index;
                col = i;
            } else if (unitType === "col") {
                row = i;
                col = index;
            } else if (unitType === "box") {
                row = Math.floor(index / 3) * 3 + Math.floor(i / 3);
                col = (index % 3) * 3 + (i % 3);
            }

            const key = `${col},${row}`;
            if (candidatesMap[key]) {
                cells.push({
                    key,
                    row,
                    col,
                    candidates: candidatesMap[key]
                });
            }
        }
        return cells;
    },

    // 统计某区域中每个候选数字出现的次数
    countCandidateOccurrences(cells) {
        const occurrences = {};
        for (let cell of cells) {
            const candidates = cell.candidates;
            if (candidates) {
                for (let candidate of candidates) {
                    occurrences[candidate] = (occurrences[candidate] || 0) + 1;
                }
            }
        }
        return occurrences;
    }
};

// 数独策略枚举
export const STRATEGIES = {
    BASIC_ELIMINATION: {
        name: 'simple strategy',
        description: '检查同行、同列和同宫格中的数字，排除已经使用的数字',
        effect: (grid) => {
            console.log('使用基本消除策略');
            return [];
        },
    },
    X_WING: {
        name: 'X-Wing',
        description: '当两行（或两列）中，某个候选数仅出现在相同的两列（或两行）时，这四个单元格形成X-Wing结构。此时，可以排除其他行或列中相同位置的该候选数。',
        effect: (grid) => {
            // 获取当前的候选数
            const candidatesMap = {};
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) {
                        const candidates = [];
                        for (let num = 1; num <= 9; num++) {
                            let canPlace = true;
                            // 检查行
                            for (let x = 0; x < 9; x++) {
                                if (grid[row][x] === num) {
                                    canPlace = false;
                                    break;
                                }
                            }
                            // 检查列
                            if (canPlace) {
                                for (let y = 0; y < 9; y++) {
                                    if (grid[y][col] === num) {
                                        canPlace = false;
                                        break;
                                    }
                                }
                            }
                            // 检查3x3方格
                            if (canPlace) {
                                const boxRow = Math.floor(row / 3) * 3;
                                const boxCol = Math.floor(col / 3) * 3;
                                for (let y = boxRow; y < boxRow + 3; y++) {
                                    for (let x = boxCol; x < boxCol + 3; x++) {
                                        if (grid[y][x] === num) {
                                            canPlace = false;
                                            break;
                                        }
                                    }
                                    if (!canPlace) break;
                                }
                            }
                            if (canPlace) {
                                candidates.push(num);
                            }
                        }
                        if (candidates.length > 0) {
                            candidatesMap[`${col},${row}`] = candidates;
                        }
                    }
                }
            }

            // 查找X-Wing模式
            const rowPatterns = XWingStrategy.findRowXWing(grid, candidatesMap);
            const colPatterns = XWingStrategy.findColXWing(grid, candidatesMap);

            // 返回找到的第一个有效模式
            const allPatterns = [...rowPatterns, ...colPatterns];
            if (allPatterns.length > 0) {
                return allPatterns[0].changes;
            }

            return [];
        }
    },
    XY_WING: {
        name: 'XY-Wing',
        description: '枢纽格有两个候选数，每个翼格也有两个候选数，且枢纽格分别与两个翼格共享一个不同的候选数。当两个翼格都包含相同的第三个候选数时，可以从同时看到两个翼格的单元格中删除这个候选数。',
        effect: (grid) => {
            const result = {
                grid: grid.map(row => [...row]),
                changed: false,
                highlights: []
            };

            // 获取候选数表
            const candidatesMap = CandidateManager.getGridCandidates(grid);

            // 找到所有双值格
            const bivalueCells = XYWingStrategy.findBivalueCells(grid, candidatesMap);

            // 寻找XY-Wing结构
            const wings = XYWingStrategy.findXYWings(bivalueCells);

            // 应用XY-Wing消除
            for (const wing of wings) {
                const { pivot, wing1, wing2, elimination } = wing;

                // 检查所有格子
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        // 跳过已填数字的格子和XY-Wing结构中的格子
                        if (grid[row][col] !== 0 || 
                            (row === pivot.row && col === pivot.col) ||
                            (row === wing1.row && col === wing1.col) ||
                            (row === wing2.row && col === wing2.col)) {
                            continue;
                        }

                        const key = `${col},${row}`;
                        // 检查是否同时看到两个翼格
                        if (XYWingStrategy.inSameUnit({ row, col }, wing1) && 
                            XYWingStrategy.inSameUnit({ row, col }, wing2)) {
                            
                            // 如果该格子包含要消除的候选数
                            if (candidatesMap[key] && candidatesMap[key].includes(elimination)) {
                                // 从候选数中移除
                                candidatesMap[key] = candidatesMap[key].filter(c => c !== elimination);
                                result.changed = true;
                                
                                // 添加高亮
                                result.highlights.push({
                                    type: 'elimination',
                                    cells: [
                                        { row, col, candidate: elimination },
                                        { row: pivot.row, col: pivot.col, candidates: pivot.candidates },
                                        { row: wing1.row, col: wing1.col, candidates: wing1.candidates },
                                        { row: wing2.row, col: wing2.col, candidates: wing2.candidates }
                                    ]
                                });
                            }
                        }
                    }
                }
            }

            return result;
        }
    },
    LAST_REMAINING_1: {
        name: 'last remaining',
        description: '从未使用的数字中选择一个',
        effect: (grid) => {
            console.log('使用最后剩余策略', grid);
              
            return [];
        }
    },
    SINGLE_CHOICE: {
        name: 'single choice',
        description: '填入唯一可能的数字',
        effect: (grid) => {
            console.log('使用单选策略');
            
            return [];
        },
    },
    HIDDEN_SINGLE: {
        name: 'Hidden Single',
        description: '在某一行、列或宫格中，某个候选数只能出现在一个特定位置时，该候选数必须被填入。',
        effect:(grid)=>{
            // console.log('执行Hidden Single策略...');
            // 获取候选数映射
            const candidatesMap = {};
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) {
                        const key = `${col},${row}`;
                        candidatesMap[key] = CandidateManager.getCandidates(grid, row, col);
                    }
                }
            }
            // console.log('当前候选数映射:', candidatesMap);

            const changes = [];
            const hiddenSingles = HiddenSingleStrategy.findHiddenSingles(grid, candidatesMap);

            // console.log('准备应用变更...');
            for (const hiddenSingle of hiddenSingles) {
                // console.log('处理Hidden Single:', hiddenSingle);
                changes.push({
                    type: 'highlight_candidate',
                    row: hiddenSingle.row,
                    col: hiddenSingle.col,
                    digit: hiddenSingle.candidate,
                    highlightType: 'eliminated'
                });
            }

            // console.log('返回的变更:', changes);
            return changes;
        }
    },
}
// 创建策略提示 store
function createStrategyHint() {
    const store = writable({
        strategy: STRATEGIES.BASIC_ELIMINATION,  // 设置默认策略
        position: null
    });

    return {
        subscribe: store.subscribe,
        setHint: (strategy, position) => {
            store.update(() => ({
                strategy: STRATEGIES[strategy] || STRATEGIES.BASIC_ELIMINATION,
                position
            }));
        },
        clear: () => {
            store.update(() => ({
                strategy: STRATEGIES.BASIC_ELIMINATION,  // 重置为默认策略
                position: null
            }));
        }
    };
}

export const strategyHint = createStrategyHint();
