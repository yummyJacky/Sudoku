import { writable } from 'svelte/store'
import { candidates } from '@sudoku/stores/candidates'
import { STRATEGIES } from '@sudoku/stragey/strategies/index'

// 添加候选数管理的工具函数
export const CandidateManager = {
    // 获取单元格的候选数
    getCandidates (grid, row, col) {
        if (grid[row][col] !== 0) return []
        const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9])

        // 检查行
        for (let c = 0; c < 9; c++) {
            if (grid[row][c] !== 0) candidates.delete(grid[row][c])
        }

        // 检查列
        for (let r = 0; r < 9; r++) {
            if (grid[r][col] !== 0) candidates.delete(grid[r][col])
        }

        // 检查3x3宫格
        const boxRow = Math.floor(row / 3) * 3
        const boxCol = Math.floor(col / 3) * 3
        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
                if (grid[boxRow + r][boxCol + c] !== 0) {
                    candidates.delete(grid[boxRow + r][boxCol + c])
                }
            }
        }

        return Array.from(candidates)
    },

    // 获取整个网格的候选数
    getGridCandidates (grid) {
        const candidates = Array(9).fill().map(() =>
            Array(9).fill().map(() => []))

        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (grid[row][col] === 0) {
                    candidates[row][col] = this.getCandidates(grid, row, col)
                }
            }
        }

        return candidates
    }
}

// 添加Y-Wing策略的实现
export const YWingStrategy = {
    // 找到所有只有两个候选数的格子
    findBivalueCells (grid, candidatesMap) {
        const bivalueCells = []
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const key = `${col},${row}`
                if (grid[row][col] === 0 && candidatesMap[key] && candidatesMap[key].length === 2) {
                    bivalueCells.push({
                        row,
                        col,
                        candidates: candidatesMap[key]
                    })
                }
            }
        }
        return bivalueCells
    },

    // 检查两个格子是否在同一个单元（行、列或宫格）内
    inSameUnit (cell1, cell2) {
        return cell1.row === cell2.row ||
            cell1.col === cell2.col ||
            (Math.floor(cell1.row / 3) === Math.floor(cell2.row / 3) &&
                Math.floor(cell1.col / 3) === Math.floor(cell2.col / 3))
    },

    // 获取两个格子共享的候选数
    getSharedCandidate (cell1, cell2) {
        return cell1.candidates.find(c => cell2.candidates.includes(c))
    },

    // 寻找XY-Wing结构
    findYWings (bivalueCells) {
        const wings = []
        // 遍历所有双值格找到可能的pivot
        for (let i = 0; i < bivalueCells.length; i++) {
            const pivot = bivalueCells[i]
            // 遍历其他格子找到可能的wing1和wing2
            for (let j = 0; j < bivalueCells.length; j++) {
                if (j === i) continue
                const wing1 = bivalueCells[j]
                if (!this.inSameUnit(pivot, wing1)) continue
                const sharedCandidate1 = this.getSharedCandidate(pivot, wing1)
                if (!sharedCandidate1) continue

                for (let k = 0; k < bivalueCells.length; k++) {
                    if (k === i || k === j) continue
                    const wing2 = bivalueCells[k]
                    if (!this.inSameUnit(pivot, wing2)) continue
                    const sharedCandidate2 = this.getSharedCandidate(pivot, wing2)
                    if (!sharedCandidate2 || sharedCandidate1 === sharedCandidate2) continue

                    // 检查wing1和wing2是否有相同的非共享候选数
                    const wing1NonShared = wing1.candidates.find(c => c !== sharedCandidate1)
                    const wing2NonShared = wing2.candidates.find(c => c !== sharedCandidate2)
                    if (wing1NonShared === wing2NonShared) {
                        wings.push({
                            pivot,
                            wing1,
                            wing2,
                            elimination: wing1NonShared
                        })
                    }
                }
            }
        }
        return wings
    }
}

// 添加X-Wing策略的实现
export const XWingStrategy = {
    // 查找行X-Wing模式
    findRowXWing (grid, candidatesMap) {
        const patterns = []
        // 遍历所有可能的数字1-9
        for (let digit = 1; digit <= 9; digit++) {
            // 记录每行中数字出现的位置
            const rowPositions = Array(9).fill().map(() => [])

            // 遍历每一行，找出候选数digit出现的列位置
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const key = `${col},${row}`
                    if (candidatesMap[key] && candidatesMap[key].includes(digit)) {
                        rowPositions[row].push(col)
                    }
                }
            }

            // 查找具有相同两个位置的行
            for (let row1 = 0; row1 < 8; row1++) {
                // 确保第一行恰好有两个候选位置
                if (rowPositions[row1].length !== 2) continue

                for (let row2 = row1 + 1; row2 < 9; row2++) {
                    // 确保第二行也恰好有两个候选位置，且位置与第一行相同
                    if (rowPositions[row2].length === 2 &&
                        rowPositions[row1][0] === rowPositions[row2][0] &&
                        rowPositions[row1][1] === rowPositions[row2][1]) {

                        // 找到X-Wing模式，生成效果
                        const col1 = rowPositions[row1][0]
                        const col2 = rowPositions[row1][1]
                        const changes = []

                        // 检查其他行的这两列是否有相同的候选数，如果有则可以删除
                        for (let r = 0; r < 9; r++) {
                            if (r !== row1 && r !== row2) {
                                const key1 = `${col1},${r}`
                                const key2 = `${col2},${r}`

                                if (candidatesMap[key1] && candidatesMap[key1].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: r,
                                        col: col1,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    })
                                }

                                if (candidatesMap[key2] && candidatesMap[key2].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: r,
                                        col: col2,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    })
                                }
                            }
                        }

                        // 高亮X-Wing的四个角
                        changes.push(
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            }
                        )

                        if (changes.length > 4) { // 如果除了四个角外还有其他要删除的候选数
                            patterns.push({
                                digit,
                                changes
                            })
                        }
                    }
                }
            }
        }
        return patterns
    },

    // 查找列X-Wing模式
    findColXWing (grid, candidatesMap) {
        const patterns = []
        // 遍历所有可能的数字1-9
        for (let digit = 1; digit <= 9; digit++) {
            // 记录每列中数字出现的位置
            const colPositions = Array(9).fill().map(() => [])

            // 遍历每一列，找出候选数digit出现的行位置
            for (let col = 0; col < 9; col++) {
                for (let row = 0; row < 9; row++) {
                    const key = `${col},${row}`
                    if (candidatesMap[key] && candidatesMap[key].includes(digit)) {
                        colPositions[col].push(row)
                    }
                }
            }

            // 查找具有相同两个位置的列
            for (let col1 = 0; col1 < 8; col1++) {
                // 确保第一列恰好有两个候选位置
                if (colPositions[col1].length !== 2) continue

                for (let col2 = col1 + 1; col2 < 9; col2++) {
                    // 确保第二列也恰好有两个候选位置，且位置与第一列相同
                    if (colPositions[col2].length === 2 &&
                        colPositions[col1][0] === colPositions[col2][0] &&
                        colPositions[col1][1] === colPositions[col2][1]) {

                        // 找到X-Wing模式，生成效果
                        const row1 = colPositions[col1][0]
                        const row2 = colPositions[col1][1]
                        const changes = []

                        // 检查其他列的这两行是否有相同的候选数，如果有则可以删除
                        for (let c = 0; c < 9; c++) {
                            if (c !== col1 && c !== col2) {
                                const key1 = `${c},${row1}`
                                const key2 = `${c},${row2}`

                                if (candidatesMap[key1] && candidatesMap[key1].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: row1,
                                        col: c,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    })
                                }

                                if (candidatesMap[key2] && candidatesMap[key2].includes(digit)) {
                                    changes.push({
                                        type: 'highlight_candidate',
                                        row: row2,
                                        col: c,
                                        digit: digit,
                                        highlightType: 'eliminated'
                                    })
                                }
                            }
                        }

                        // 高亮X-Wing的四个角
                        changes.push(
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row1,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col1,
                                digit: digit,
                                highlightType: 'xwing'
                            },
                            {
                                type: 'highlight_candidate',
                                row: row2,
                                col: col2,
                                digit: digit,
                                highlightType: 'xwing'
                            }
                        )

                        if (changes.length > 4) { // 如果除了四个角外还有其他要删除的候选数
                            patterns.push({
                                digit,
                                changes
                            })
                        }
                    }
                }
            }
        }
        return patterns
    }
}

// 添加Hidden Single策略的实现
export const HiddenSingleStrategy = {
    // 遍历某一行、列或宫格，查找Hidden Single
    findHiddenSingles (grid, candidatesMap) {
        const hiddenSingles = new Set() // 使用Set避免重复
        // console.log('开始查找Hidden Singles...');

        // 遍历所有行、列和宫格
        for (let unitType of ["row", "col", "box"]) {
            for (let index = 0; index < 9; index++) {
                // console.log(`检查${unitType} ${index}`);
                const cells = this.getUnitCells(grid, unitType, index, candidatesMap)
                const candidateOccurrences = this.countCandidateOccurrences(cells)

                // console.log('候选数出现次数:', candidateOccurrences);

                // 找到出现次数为1的候选数字，并记录
                for (let [candidate, count] of Object.entries(candidateOccurrences)) {
                    if (count === 1) {
                        // console.log(`在${unitType} ${index}中找到Hidden Single: 数字${candidate}`);
                        const targetCell = cells.find(cell =>
                            cell.candidates.includes(Number(candidate))
                        )
                        if (targetCell) {
                            // console.log(`位置: 行${targetCell.row}, 列${targetCell.col}`);
                            const key = JSON.stringify({
                                row: targetCell.row,
                                col: targetCell.col,
                                candidate: Number(candidate)
                            })
                            hiddenSingles.add(key)
                        }
                    }
                }
            }
        }

        const result = Array.from(hiddenSingles).map(key => JSON.parse(key))
        // console.log('找到的所有Hidden Singles:', result);
        return result
    },

    // 获取某一行、列或宫格的格子
    getUnitCells (grid, unitType, index, candidatesMap) {
        const cells = []
        for (let i = 0; i < 9; i++) {
            let row, col

            if (unitType === "row") {
                row = index
                col = i
            } else if (unitType === "col") {
                row = i
                col = index
            } else if (unitType === "box") {
                row = Math.floor(index / 3) * 3 + Math.floor(i / 3)
                col = (index % 3) * 3 + (i % 3)
            }

            const key = `${col},${row}`
            if (candidatesMap[key]) {
                cells.push({
                    key,
                    row,
                    col,
                    candidates: candidatesMap[key]
                })
            }
        }
        return cells
    },

    // 统计某区域中每个候选数字出现的次数
    countCandidateOccurrences (cells) {
        const occurrences = {}
        for (let cell of cells) {
            const candidates = cell.candidates
            if (candidates) {
                for (let candidate of candidates) {
                    occurrences[candidate] = (occurrences[candidate] || 0) + 1
                }
            }
        }
        return occurrences
    }
}


// 创建策略提示 store
function createStrategyHint () {
    const store = writable({
        strategy: STRATEGIES.LAST_REMAINING_1,  // 设置默认策略
        position: null
    })

    return {
        subscribe: store.subscribe,
        setHint: (strategy, position) => {
            store.update(() => ({
                strategy: STRATEGIES[strategy] || STRATEGIES.BASIC_ELIMINATION,
                position
            }))
        },
        clear: () => {
            store.update(() => ({
                strategy: STRATEGIES.BASIC_ELIMINATION,  // 重置为默认策略
                position: null
            }))
        }
    }
}

export const strategyHint = createStrategyHint()
