// 添加Y-Wing策略的实现
export const YWingStrategy = {
    // 找到所有只有两个候选数的格子
    findBivalueCells (grid, candidatesMap) {
        const bivalueCells = []
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const key = `${col},${row}`
                if (grid[row][col] === 0 && candidatesMap[key] && candidatesMap[key].length === 2) {
                    bivalueCells.push({
                        row,
                        col,
                        candidates: candidatesMap[key]
                    })
                }
            }
        }
        return bivalueCells
    },

    // 检查两个格子是否在同一个单元（行、列或宫格）内
    inSameUnit (cell1, cell2) {
        return cell1.row === cell2.row ||
            cell1.col === cell2.col ||
            (Math.floor(cell1.row / 3) === Math.floor(cell2.row / 3) &&
                Math.floor(cell1.col / 3) === Math.floor(cell2.col / 3))
    },

    // 获取两个格子共享的候选数
    getSharedCandidate (cell1, cell2) {
        return cell1.candidates.find(c => cell2.candidates.includes(c))
    },

    // 寻找XY-Wing结构
    findYWings (bivalueCells) {
        const wings = []
        // 遍历所有双值格找到可能的pivot
        for (let i = 0; i < bivalueCells.length; i++) {
            const pivot = bivalueCells[i]
            // 遍历其他格子找到可能的wing1和wing2
            for (let j = 0; j < bivalueCells.length; j++) {
                if (j === i) continue
                const wing1 = bivalueCells[j]
                if (!this.inSameUnit(pivot, wing1)) continue
                const sharedCandidate1 = this.getSharedCandidate(pivot, wing1)
                if (!sharedCandidate1) continue

                for (let k = 0; k < bivalueCells.length; k++) {
                    if (k === i || k === j) continue
                    const wing2 = bivalueCells[k]
                    if (!this.inSameUnit(pivot, wing2)) continue
                    const sharedCandidate2 = this.getSharedCandidate(pivot, wing2)
                    if (!sharedCandidate2 || sharedCandidate1 === sharedCandidate2) continue

                    // 检查wing1和wing2是否有相同的非共享候选数
                    const wing1NonShared = wing1.candidates.find(c => c !== sharedCandidate1)
                    const wing2NonShared = wing2.candidates.find(c => c !== sharedCandidate2)
                    if (wing1NonShared === wing2NonShared) {
                        wings.push({
                            pivot,
                            wing1,
                            wing2,
                            elimination: wing1NonShared
                        })
                    }
                }
            }
        }
        return wings
    }
}


export const Y_WING = {
    name: 'Y-Wing',
    description: 'Y-Wing是一种高级策略，涉及三个单元格，每个单元格有两个候选数，形成特定的模式。',
    
    // 检查策略是否适用
    async check(grid) {
        const result = await this.effect(grid);
        return result.length > 0 ? {
            hasChanges: () => true,
            strategy: this,
            description: this.description
        } : null;
    },

    effect: (grid) => {
        const result = {
            grid: grid.map(row => [...row]),
            changed: false,
            highlights: []
        }

        // 获取候选数表
        const candidatesMap = CandidateManager.getGridCandidates(grid)

        // 找到所有双值格
        const bivalueCells = YWingStrategy.findBivalueCells(grid, candidatesMap)

        // 寻找Y-Wing结构
        const wings = YWingStrategy.findYWings(bivalueCells)

        // 应用Y-Wing消除
        for (const wing of wings) {
            const { pivot, wing1, wing2, elimination } = wing

            // 检查所有格子
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    // 跳过已填数字的格子和Y-Wing结构中的格子
                    if (grid[row][col] !== 0 ||
                        (row === pivot.row && col === pivot.col) ||
                        (row === wing1.row && col === wing1.col) ||
                        (row === wing2.row && col === wing2.col)) {
                        continue
                    }

                    const key = `${col},${row}`
                    // 检查是否同时看到两个翼格
                    if (YWingStrategy.inSameUnit({ row, col }, wing1) &&
                        YWingStrategy.inSameUnit({ row, col }, wing2)) {

                        // 如果该格子包含要消除的候选数
                        if (candidatesMap[key] && candidatesMap[key].includes(elimination)) {
                            // 从候选数中移除
                            candidatesMap[key] = candidatesMap[key].filter(c => c !== elimination)
                            result.changed = true

                            // 添加高亮
                            result.highlights.push({
                                type: 'elimination',
                                cells: [
                                    { row, col, candidate: elimination },
                                    { row: pivot.row, col: pivot.col, candidates: pivot.candidates },
                                    { row: wing1.row, col: wing1.col, candidates: wing1.candidates },
                                    { row: wing2.row, col: wing2.col, candidates: wing2.candidates }
                                ]
                            })
                        }
                    }
                }
            }
        }

        return result
    }
}