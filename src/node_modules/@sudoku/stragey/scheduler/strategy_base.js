/**
 * 数独策略核心实现
 * 包含了数独解题策略的基础类和工具类
 * 主要包括：策略点位、策略组、扫描器、调度器和基础策略类
 */

/**
 * 策略单元格类
 * 表示数独中的一个单元格位置及其候选数
 */
class StrategyPoint {
    /**
     * @param {number} row - 行坐标（0-8）
     * @param {number} col - 列坐标（0-8）
     * @param {number[]} candidates - 候选数列表
     */
    constructor(row, col, candidates = []) {
        this.row = row;
        this.col = col;
        // 深拷贝候选数数组，避免引用问题
        this.highlightCandidates = [...candidates];
    }

    /**
     * 将点位转换为字符串表示
     * @returns {string} 格式化的坐标字符串
     */
    toString() {
        return `(${this.row},${this.col})`;
    }

    /**
     * 比较两个点位是否相同
     * @param {StrategyPoint} other - 要比较的另一个点位
     * @returns {boolean} 是否相同
     */
    equals(other) {
        return this.row === other.row && this.col === other.col;
    }
}

/**
 * 策略分析单元类
 * 用于存储策略分析的结果，包括受影响的点位和需要删除的候选数
 */
class StrategyGroup {
    /**
     * @param {string} name - 策略组名称
     * @param {string} description - 策略组描述
     */
    constructor(name, description = '') {
        this.groupName = name;
        this.description = description;
        // 使用Set存储点位，避免重复
        this.points = new Set();
        this.affectedPoints = new Set();
        // 使用Map存储每个点位需要删除的候选数
        this.eliminatedCandidates = new Map();
    }

    /**
     * 添加策略点位
     * @param {StrategyPoint} point - 策略点位
     * @param {number[]} candidates - 相关的候选数
     */
    addPoint(point, candidates) {
        this.points.add(point);
        if (candidates && candidates.length > 0) {
            point.highlightCandidates = candidates;
        }
    }

    /**
     * 添加受影响的点位
     * @param {StrategyPoint} point - 受影响的点位
     * @param {number[]} candidates - 需要删除的候选数
     */
    addAffectedPoint(point, candidates) {
        this.affectedPoints.add(point);
        if (candidates && candidates.length > 0) {
            this.eliminatedCandidates.set(point.toString(), candidates);
        }
    }

    /**
     * 获取所有策略点位
     * @returns {StrategyPoint[]} 策略点位数组
     */
    getPoints() {
        return Array.from(this.points);
    }

    /**
     * 获取所有受影响的点位
     * @returns {StrategyPoint[]} 受影响的点位数组
     */
    getAffectedPoints() {
        return Array.from(this.affectedPoints);
    }

    /**
     * 检查是否有任何变更
     * @returns {boolean} 是否有变更
     */
    hasChanges() {
        return this.points.size > 0 || this.affectedPoints.size > 0;
    }
}

/**
 * 策略扫描器类
 * 用于遍历数独盘面的不同区域（行、列、宫）
 */
class StrategyScanner {
    /**
     * @param {Object} config - 扫描配置
     * @param {boolean} config.scanRows - 是否扫描行
     * @param {boolean} config.scanCols - 是否扫描列
     * @param {boolean} config.scanBoxes - 是否扫描宫
     * @param {Function} config.customScan - 自定义扫描函数
     */
    constructor(config = {
        scanRows: true,
        scanCols: true,
        scanBoxes: true,
        customScan: null
    }) {
        this.config = config;
    }

    /**
     * 扫描某一行的所有单元格
     * @param {number} row - 行号
     * @yields {StrategyPoint} 行内的每个点位
     */
    *scanRow(row) {
        for (let col = 0; col < 9; col++) {
            yield new StrategyPoint(row, col);
        }
    }

    /**
     * 扫描某一列的所有单元格
     * @param {number} col - 列号
     * @yields {StrategyPoint} 列内的每个点位
     */
    *scanCol(col) {
        for (let row = 0; row < 9; row++) {
            yield new StrategyPoint(row, col);
        }
    }

    /**
     * 扫描某一宫的所有单元格
     * @param {number} boxIndex - 宫号（0-8）
     * @yields {StrategyPoint} 宫内的每个点位
     */
    *scanBox(boxIndex) {
        const startRow = Math.floor(boxIndex / 3) * 3;
        const startCol = (boxIndex % 3) * 3;
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                yield new StrategyPoint(startRow + i, startCol + j);
            }
        }
    }

    /**
     * 执行扫描操作
     * @param {Object} grid - 数独盘面对象
     * @param {Function} callback - 处理每个区域的回调函数
     * @returns {Promise<Array>} 扫描结果数组
     */
    async scan(grid, callback) {
        const results = [];

        // 扫描行
        if (this.config.scanRows) {
            for (let row = 0; row < 9; row++) {
                const points = Array.from(this.scanRow(row));
                const result = await callback(points, grid);
                if (result) results.push(result);
            }
        }

        // 扫描列
        if (this.config.scanCols) {
            for (let col = 0; col < 9; col++) {
                const points = Array.from(this.scanCol(col));
                const result = await callback(points, grid);
                if (result) results.push(result);
            }
        }

        // 扫描宫
        if (this.config.scanBoxes) {
            for (let box = 0; box < 9; box++) {
                const points = Array.from(this.scanBox(box));
                const result = await callback(points, grid);
                if (result) results.push(result);
            }
        }

        // 执行自定义扫描
        if (this.config.customScan) {
            const result = await this.config.customScan(grid, callback);
            if (result) results.push(result);
        }

        return results;
    }
}

/**
 * 策略调度器类
 * 管理和调度不同的解题策略
 */
class StrategyScheduler {
    constructor() {
        this.strategies = new Map();
        this.currentStrategy = null;
        this.difficultyLevels = new Map([
            ['easy', 1],
            ['medium', 2],
            ['hard', 3]
        ]);
    }

    /**
     * 注册新策略
     * @param {BaseStrategy} strategy - 策略实例
     * @param {string} difficulty - 策略难度
     */
    registerStrategy(strategy, difficulty = 'medium') {
        const level = this.difficultyLevels.get(difficulty) || 2;
        this.strategies.set(strategy.id, {
            strategy,
            difficulty: level,
            enabled: true
        });
    }

    /**
     * 查找下一个适用的策略
     * @param {Object} grid - 数独盘面对象
     * @returns {Promise<BaseStrategy>} 找到的策略实例
     */
    async findNextStrategy(grid) {
        let bestMatch = null;
        let minDifficulty = Infinity;

        for (const [id, {strategy, difficulty, enabled}] of this.strategies) {
            if (!enabled) continue;

            const result = await strategy.check(grid);
            if (result && result.hasChanges() && difficulty < minDifficulty) {
                bestMatch = strategy;
                minDifficulty = difficulty;
            }
        }

        this.currentStrategy = bestMatch;
        return bestMatch;
    }

    /**
     * 设置策略的启用状态
     * @param {string} strategyId - 策略ID
     * @param {boolean} enabled - 是否启用
     */
    setStrategyEnabled(strategyId, enabled) {
        const strategyInfo = this.strategies.get(strategyId);
        if (strategyInfo) {
            strategyInfo.enabled = enabled;
        }
    }

    /**
     * 获取当前正在使用的策略
     * @returns {BaseStrategy} 当前策略实例
     */
    getCurrentStrategy() {
        return this.currentStrategy;
    }
}

/**
 * 基础策略类
 * 所有具体策略的基类，提供通用功能
 */
class BaseStrategy {
    /**
     * @param {string} id - 策略唯一标识
     * @param {string} name - 策略名称
     * @param {string} description - 策略描述
     */
    constructor(id, name, description) {
        this.id = id;
        this.name = name;
        this.description = description;
        this.scanner = new StrategyScanner();
        this.difficulty = 'medium';
    }

    /**
     * 初始化策略
     * 子类可以重写此方法进行初始化
     */
    initialize() {
    }

    /**
     * 检查策略是否适用于当前盘面
     * @param {Object} grid - 数独盘面对象
     * @returns {Promise<StrategyGroup>} 检查结果
     */
    async check(grid) {
        return await this.apply(grid);
    }

    /**
     * 分析单个区域
     * @param {StrategyPoint[]} points - 区域内的点位
     * @param {Object} grid - 数独盘面对象
     * @returns {Promise<StrategyGroup>} 分析结果
     */
    async analyzeRegion(points, grid) {
        throw new Error('BaseStrategy.analyzeRegion() must be implemented by subclass');
    }

    /**
     * 应用策略到盘面
     * @param {Object} grid - 数独盘面对象
     * @returns {Promise<StrategyGroup>} 应用结果
     */
    async apply(grid) {
        this.initialize();
        const results = await this.scanner.scan(grid, async (points, grid) => {
            return await this.analyzeRegion(points, grid);
        });
        return this.processResults(results);
    }

    /**
     * 处理策略应用的结果
     * @param {StrategyGroup[]} results - 原始结果数组
     * @returns {StrategyGroup} 处理后的结果
     */
    processResults(results) {
        const validResults = results.filter(r => r && r.hasChanges());
        if (validResults.length === 0) return null;

        const finalGroup = new StrategyGroup(this.name, this.description);
        for (const result of validResults) {
            for (const point of result.getPoints()) {
                finalGroup.addPoint(point, point.highlightCandidates);
            }
            for (const point of result.getAffectedPoints()) {
                const candidates = result.eliminatedCandidates.get(point.toString());
                finalGroup.addAffectedPoint(point, candidates);
            }
        }

        return finalGroup;
    }

    /**
     * 获取单元格的候选数
     * @param {Object} grid - 数独盘面对象
     * @param {StrategyPoint} point - 目标点位
     * @returns {number[]} 候选数列表
     */
    getCandidates(grid, point) {
        return grid.getCandidates(point.row, point.col);
    }

    /**
     * 检查单元格是否已解决
     * @param {Object} grid - 数独盘面对象
     * @param {StrategyPoint} point - 目标点位
     * @returns {boolean} 是否已解决
     */
    isSolved(grid, point) {
        return grid.isSolved(point.row, point.col);
    }

    /**
     * 设置策略难度
     * @param {string} difficulty - 难度等级
     * @returns {BaseStrategy} 策略实例本身（用于链式调用）
     */
    setDifficulty(difficulty) {
        this.difficulty = difficulty;
        return this;
    }
}

// 创建全局调度器实例
const globalScheduler = new StrategyScheduler();

export {
    StrategyPoint,
    StrategyGroup,
    StrategyScanner,
    BaseStrategy,
    StrategyScheduler,
    globalScheduler
}; 