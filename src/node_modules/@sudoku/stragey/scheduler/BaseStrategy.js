import { StrategyGroup } from './StrategyGroup';
import { StrategyScanner } from './StrategyScanner';

/**
 * 基础策略类
 * 所有具体策略的基类，提供通用功能
 */
export class BaseStrategy {
    /**
     * @param {string} id - 策略唯一标识
     * @param {string} name - 策略名称
     * @param {string} description - 策略描述
     */
    constructor(id, name, description) {
        this.id = id;
        this.name = name;
        this.description = description;
        this.scanner = new StrategyScanner();
        this.difficulty = 'medium';
    }

    /**
     * 初始化策略
     * 子类可以重写此方法进行初始化
     */
    initialize() {
    }

    /**
     * 检查策略是否适用于当前盘面
     * @param {Object} grid - 数独盘面对象
     * @returns {Promise<StrategyGroup>} 检查结果
     */
    async check(grid) {
        return await this.apply(grid);
    }

    /**
     * 分析单个区域
     * @param {StrategyPoint[]} points - 区域内的点位
     * @param {Object} grid - 数独盘面对象
     * @returns {Promise<StrategyGroup>} 分析结果
     */
    async analyzeRegion(points, grid) {
        throw new Error('BaseStrategy.analyzeRegion() must be implemented by subclass');
    }

    /**
     * 应用策略到盘面
     * @param {Object} grid - 数独盘面对象
     * @returns {Promise<StrategyGroup>} 应用结果
     */
    async apply(grid) {
        this.initialize();
        const results = await this.scanner.scan(grid, async (points, grid) => {
            return await this.analyzeRegion(points, grid);
        });
        return this.processResults(results);
    }

    /**
     * 处理策略应用的结果
     * @param {StrategyGroup[]} results - 原始结果数组
     * @returns {StrategyGroup} 处理后的结果
     */
    processResults(results) {
        const validResults = results.filter(r => r && r.hasChanges());
        if (validResults.length === 0) return null;

        const finalGroup = new StrategyGroup(this.name, this.description);
        for (const result of validResults) {
            for (const point of result.getPoints()) {
                finalGroup.addPoint(point, point.highlightCandidates);
            }
            for (const point of result.getAffectedPoints()) {
                const candidates = result.eliminatedCandidates.get(point.toString());
                finalGroup.addAffectedPoint(point, candidates);
            }
        }

        return finalGroup;
    }

    /**
     * 获取单元格的候选数
     * @param {Object} grid - 数独盘面对象
     * @param {StrategyPoint} point - 目标点位
     * @returns {number[]} 候选数列表
     */
    getCandidates(grid, point) {
        return grid.getCandidates(point.row, point.col);
    }

    /**
     * 检查单元格是否已解决
     * @param {Object} grid - 数独盘面对象
     * @param {StrategyPoint} point - 目标点位
     * @returns {boolean} 是否已解决
     */
    isSolved(grid, point) {
        return grid.isSolved(point.row, point.col);
    }

    /**
     * 设置策略难度
     * @param {string} difficulty - 难度等级
     * @returns {BaseStrategy} 策略实例本身（用于链式调用）
     */
    setDifficulty(difficulty) {
        this.difficulty = difficulty;
        return this;
    }
} 