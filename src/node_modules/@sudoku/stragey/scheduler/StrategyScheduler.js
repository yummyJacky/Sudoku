/**
 * 策略调度器类
 * 管理和调度不同的解题策略
 */
export class StrategyScheduler {
    constructor() {
        this.strategies = new Map();
        this.currentStrategy = null;
        this.difficultyLevels = new Map([
            ['easy', 1],
            ['medium', 2],
            ['hard', 3]
        ]);
    }

    /**
     * 注册新策略
     * @param {BaseStrategy} strategy - 策略实例
     * @param {string} difficulty - 策略难度
     */
    registerStrategy(strategy, difficulty = 'medium') {
        const level = this.difficultyLevels.get(difficulty) || 2;
        this.strategies.set(strategy.id, {
            strategy,
            difficulty: level,
            enabled: true
        });
    }

    /**
     * 查找下一个适用的策略
     * @param {Object} grid - 数独盘面对象
     * @returns {Promise<BaseStrategy>} 找到的策略实例
     */
    async findNextStrategy(grid) {
        let bestMatch = null;
        let minDifficulty = Infinity;

        for (const [id, {strategy, difficulty, enabled}] of this.strategies) {
            if (!enabled) continue;

            const result = await strategy.check(grid);
            if (result && result.hasChanges() && difficulty < minDifficulty) {
                bestMatch = strategy;
                minDifficulty = difficulty;
            }
        }

        this.currentStrategy = bestMatch;
        return bestMatch;
    }

    /**
     * 设置策略的启用状态
     * @param {string} strategyId - 策略ID
     * @param {boolean} enabled - 是否启用
     */
    setStrategyEnabled(strategyId, enabled) {
        const strategyInfo = this.strategies.get(strategyId);
        if (strategyInfo) {
            strategyInfo.enabled = enabled;
        }
    }

    /**
     * 获取当前正在使用的策略
     * @returns {BaseStrategy} 当前策略实例
     */
    getCurrentStrategy() {
        return this.currentStrategy;
    }
}

// 创建全局调度器实例
export const strategyScheduler = new StrategyScheduler(); 